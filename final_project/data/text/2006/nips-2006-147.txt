Learning annotated hierarchies from relational data

Daniel M. Roy, Charles Kemp, Vikash K. Mansinghka, and Joshua B. Tenenbaum
CSAIL, Dept. of Brain & Cognitive Sciences, MIT, Cambridge, MA 02139
{droy, ckemp, vkm, jbt}@mit.edu

Abstract

The objects in many real-world domains can be organized into hierarchies, where
each internal node picks out a category of objects. Given a collection of fea-
tures and relations de ﬁned over a set of objects, an annotated hierarchy includes a
speciﬁcation of the categories that are most useful for desc ribing each individual
feature and relation. We de ﬁne a generative model for annota ted hierarchies and
the features and relations that they describe, and develop a Markov chain Monte
Carlo scheme for learning annotated hierarchies. We show that our model discov-
ers interpretable structure in several real-world data sets.

1 Introduction

Researchers in AI and cognitive science [1, 7] have proposed that hierarchies are useful for rep-
resenting and reasoning about the objects in many real-world domains. One of the reasons that
hierarchies are valuable is that they compactly specify categories at many levels of resolution, each
node representing the category of objects at the leaves below the node. Consider, for example, the
simple hierarchy shown in Figure 1a, which picks out ﬁve cate gories relevant to a typical university
department: employees, staff, faculty, professors, and assistant professors.

Suppose that we are given a large data set describing the features of these employees and the in-
teractions among these employees. Each of the ﬁve categorie s will account for some aspects of
the data, but different categories will be needed for understanding different features and relations.
“Faculty,” for example, is the single most useful category f or describing the employees that publish
papers (Figure 1b), but three categories may be needed to describe the social interactions among the
employees (Figure 1c). In order to understand the structure of the department, it is important not
only to understand the hierarchical organization of the employees, but to understand which levels in
the hierarchy are appropriate for describing each feature and each relation. Suppose, then, that an
annotated hierarchy is a hierarchy along with a speciﬁcation of the categories in the hierarchy that
are relevant to each feature and relation.

The idea of an annotated hierarchy is one of the oldest proposals in cognitive science, and researchers
including Collins and Quillian [1] and Keil [7] have argued that semantic knowledge is organized
into representations with this form. Previous treatments of annotated hierarchies, however, usually
suffer from two limitations. First, annotated hierarchies are usually hand-engineered, and there
are few proposals describing how they might be learned from data. Second, annotated hierarchies
typically capture knowledge only about the features of objects: relations between objects are rarely
considered. We address both problems by de ﬁning a generativ e model for objects, features, relations,
and hierarchies, and showing how it can be used to recover an annotated hierarchy from raw data.

Our generative model for feature data assumes that the objects are located at the leaves of a rooted
tree, and that each feature is generated from a partition of the objects “consistent” with the hierarchy.
A tree-consistent partition (henceforth, t-c partition) of the objects is a partition of the objects into
disjoint categories, i.e. each class in the partition is exactly the set of leaves descending from some
node in the tree. Therefore, a t-c partition can be uniquely encoded as the set of these nodes whose
leaf descendants comprise the classes (Figure 1a,b). The simplest t-c partition is the singleton set

True

False

(a)

Employees (E)

(b)

Staff (S)

Faculty (F)

Professors (P)

F

Assistant Profs (A)

A

F

Direct−Deposit
Has Tenure
Publishes
SS
E

P E

E

F

E

F

E

F

t
A

S

P

A

S

P

A

S

P

A

w

A

S,S

S,F

S,S

S,F

S,E

F,S

P,P P,A

A,P

A,A

F,S

F,F

P,S

P,P P,A

A,E

(c)

S

P

A

works with
orders around
friends with
Figure 1: (a) A hierarchy over 15 members of a university department: 5 staff members, 5 professors and
5 assistant professors. (b) Three binary features, each of which is associated with a different t-c partition of
the objects. Each class in each partition is labeled with the corresponding node in the tree. (c) Three binary
relations, each of which is associated with a different t-c partition of the set of object pairs. Each class in each
partition is labeled with the corresponding pair of nodes.

containing the root node, which places all objects into a single class. The most complex t-c partition
is the set of all leaves, which assigns each object to its own class. We assume that the features of
objects in different classes are independent, but that objects in the same class tend to have similar
features. Therefore, ﬁnding the categories in the tree most
relevant to a feature can be formalized
as ﬁnding the simplest t-c partition that best accounts for t he distribution of the feature (Figure 1b).
We de ﬁne an annotated hierarchy as a hierarchy together with a t-c partition for each feature.

Although most discussions of annotated hierarchies focus on features, much of the data available
to human learners comes in the form of relations. Understanding the structure of social groups, for
instance, involves inferences about relations like admires(·, ·), friend-of (·, ·) and brother-of (·, ·).
Like the feature case, our generative model for relational data assumes that each (binary) relation
is generated from a t-c partition of the set of all pairs of objects. Each class in a t-c partition now
corresponds to a pair of categories (i.e. pair of nodes) (Figure 1c), and we assume that all pairs in a
given class tend to take similar values. As in the feature case, ﬁnding the categories in the tree most
relevant to a relation can be formalized as ﬁnding the t-c par tition that best accounts for the distribu-
tion of the relation. The t-c partition for each relation can be viewed as an additional annotation of
the tree. The ﬁnal piece of our generative model is a prior ove r rooted trees representing hierarchies.
Roughly speaking, the best hierarchy will then be the one that provides the best categories with
which to summarize all the features and relations.

Like other methods for discovering structure in data, our approach may be useful both as a tool
for data analysis and as a model of human learning. After describing our approach, we apply it to
several data sets inspired by problems faced by human learners. Our ﬁrst analysis suggests that the
model recovers coherent domains given objects and features from several domains (animals, foods,
tools and vehicles). Next we show that the model discovers interpretable structure in kinship data,
and in data representing relationships between ontological kinds.

2 A generative model for features and relations

Our approach is organized around a generative model for feature data and relational data. For sim-
plicity, we present our model for feature and relational data separately, focusing on the case where
we have a single binary feature or a single binary relation. After presenting our generative model,
we describe how it can be used to recover annotated hierarchies from data.

We begin with the case of a single binary feature and de ﬁne a jo int distribution over three entities:
a rooted, weighted, binary tree T with O objects at the leaves; a t-c partition of the objects; and
feature observations, d. For a feature, a t-c partition π is a set of nodes {n1 , n2 , . . . , nk }, such that
each object is a descendant of exactly one node in π . We will identify each node with the category
of objects descending from it. We denote the data for all objects in the category n as dn . If o is a
leaf (single object category), then do is the value of the feature for object o. In Figure 1b, three t-c
partitions associated with the hierarchy are represented and each class in each partition is labeled
with the corresponding category.
The joint distribution P (T , w, π , d|λ, γf ) is induced by the following generative process:

i. Sample a tree T from a uniform distribution over rooted binary trees with O leaves (each
leaf will represent an object and there are O objects). Each node n represents a category.
ii. For each category n, sample its weight, wn , according to an exponential distribution with
parameter λ, i.e. p(wn |λ) = λe−λwn .
iii. Sample a t-c partition πf = {n1 , n2 , . . . , nk } ∼ Π(root-of(T )), where Π(n) is a
stochastic, set-valued function:
n is a leaf, or w.p. φ(wn )
Π(n) = (cid:26){n}
∪iΠ(ni ) otherwise
where φ(x) = 1 − e−x and ni are the children of n. Intuitively, categories with large weight
are more likely to be classes in the partition. For the publishes feature in Figure 1b, the t-c
partition is {F, S }.
iv. For each category n ∈ πf , sample θn ∼ Beta(γf , γf ), where θn is the probability that
objects in category n exhibit the feature f . Returning to the publishes example in Figure 1b,
two parameters, θF and θS , would be drawn for this feature.
v. For each object o, sample its feature value do ∼ Bernoulli(θn ), where n ∈ πf is the
category containing o.

(1)

Consider now the case where we have a single binary relation de ﬁned over all ordered pairs of
objects {(oi , oj )}. In the relational case, our joint distribution is de ﬁned ov er a rooted, weighted,
binary tree; a t-c partition of ordered pairs of objects; and observed, relational data represented as a
matrix D where Di,j = 1 if the relation holds between oi and oj .
Given a pair of categories (ni , mj ), let ni × mj be the set of all pairs of objects (oi , oj ) such that oi
is an object in the category ni and oj is an object in the category mj . With respect to pairs of trees, a
t-c partition, π , is a set of pairs of categories {(n1 , m1 ), (n2 , m2 ), . . . , (nk , mk )} such that, for every
pair of objects (oi , oj ), there exists exactly one pair (nk , mk ) ∈ π such that (oi , oj ) ∈ nk × mk .
To help visualize these 2D t-c partitions, we can reorder the columns and rows of the matrix D
according to an in-order traversal of the binary tree T . Each t-c partition now splits the matrix
into contiguous, rectangular blocks (see Figure 1c, where each rectangular block is labeled with its
category pair). Assuming we have already generated a rooted, weighted binary tree, we now specify
the generative process for a single binary relation (c.f. steps iii through v in the feature case):

(2)

iii. Sample a t-c partition πr = {(n1 , m1 ), . . . , (nk , mk )} ∼ Π(root-of(T ), root-of(T )),
where Π(n, m) is a stochastic, set-valued function:
w.p. φ(wn ) · φ(wm )
Π(n, m) = 
{(n, m)}
otherwise, w.p. 1
∪iΠ(ni , m)
2
∪j Π(n, mj ) otherwise

where ni/mj are the children of n/m. To handle special cases, if both n, m are leaves,
Π(n, m) = {n, m}; if only one of the nodes is a leaf, we default to the feature case on the
remaining tree, halting with probability φ(wn ) · φ(wm ). Intuitively, if a pair of categories
(n, m) both have large weight, the process is more likely to group all pairs of objects in
n × m into a single class. In Figure 1c, the t-c partition for the works with relation is
{(S, S ), (S, F ), (F, S ), (F, F )}.
iv. For each pair of categories (n, m) ∈ πr , sample θn,m ∼ Beta(γr , γr ), where θn,m is the
probability that the relation holds between any pair of objects in n × m. For the works
with relation in Figure 1c, parameters would be drawn for each of the four classes in the t-c
partition.
v. For each pair of objects (oi , oj ), sample the relation Di,j ∼ Bernoulli(θn,m ), where
(n, m) ∈ πr and (oi , oj ) ∈ (n, m). That is, the probability that the relation holds is
the same for all pairs in a given class.

For data sets with multiple relations and features, we assume that all relations and features are
conditionally independent given the weighted tree T .

2.1 Inference

Given observations of features and relations, we can use the generative model to ask various ques-
tions about the latent hierarchy and its annotations. We start by determining the posterior distribution
on the weighted tree topologies, (T , w), given data D = ({d(f )}F
r=1) over O objects,
f =1 , {D(r)}R
F features and R relations and hyperparameters λ and γ = ({γf }F
r=1). By Bayes’ rule,
f =1 , {γr }R

R

P (T , w|D, λ, γ ) ∝ P (T ) P (w|T , λ)
P (D|T , w, γ )
F
P (D(r) |T , w, γr )(cid:17).
∝ (cid:16)1(cid:17)
(cid:16)Yn
λe−λwn (cid:17) (cid:16)Y
P (d(f ) |T , w, γf ) Y
r=1
f =1
But P (d(f ) |T , w, γf ) = Pπ P (π |T , w) P (d(f ) |π , γf ), where P (π |T , w) is the distribution over
t-c partitions induced by the stochastic function Π and P (d(f ) |π , γf ) is the likelihood given
the partition, marginalizing over the feature probabilities, θn . Because the classes are indepen-
dent, P (d(f ) |π , γf ) = Qn∈π P (d(f )
n |n ∈ π , γf ), where Mf (n) = P (d(f )
n |n ∈ π , γf ) is the
marginal likelihood for d(f )
n , the features for objects in category n. For our binary-valued data
sets, Mf (n) is the standard marginal likelihood for the beta-binomial model. Because there are
an exponential number of t-c partitions, we present an efﬁci ent dynamic program for calculating
Tf (n) = P (d(f )
n |T , w, γf ). Then, Tf (root-of(T )) = P (d(f ) |T , w, γf ) is the desired quantity.
First observe that, for all objects (i.e. leaf nodes) o, Tf (o) = Mf (o). Let n be a node and assume no
ancestor of n is in π . With probability φ(wn ) = 1 − e−wn , category n will be a single class and the
contribution to Tf will be Mf (n). Otherwise, Π(n) splits category n into its children, n1 and n2 .
Now the possible partitions of the objects in category n are every t-c partition of the objects below n1
paired with every t-c partition below n2 . By independence, this contributes Tf (n1 )Tf (n2 ). Hence,
Tf (n) = (cid:26)φ(wn )Mf (n) + (1 − φ(wn )) Tf (n1 )Tf (n2 )
Mf (n)
For the relational case, we describe a dynamic program Tr (n, m) that calculates P (D(r)
n,m |T , w, γr ),
the probability of all relations between objects in n×m, conditioned on the tree, having marginalized
out the t-c partitions and relation probabilities. Let Mr (n, m) = P (D(r)
n,m |(n, m) ∈ π , γr ) be the
marginal likelihood of the relations in n × m. For relations, Mf (n, m) is also the beta-binomial. If
n and m are both leaves, then Tr (n, m) = Mr (n, m). Otherwise,

if n is an internal node
otherwise.

Tr (n, m) = φ(wn ) φ(wm )Mr (n, m)
n is a leaf
+ (1 − φ(wn ) φ(wm )) 
Tr (n, m1 )Tr (n, m2 )
m is a leaf
(Tr (n1 , m)Tr (n2 , m)
1
2 · (Tr (n, m1 )Tr (n, m2 ) + Tr (n1 , m)Tr (n2 , m)) otherwise

The above dynamic programs have linear and quadratic complexity in the number of objects, re-
spectively. Because we can efﬁciently compute the posterio r density of a weighted tree, we can
search for the maximum a posteriori (MAP) weighted tree. Conditioned on the MAP tree, we can
efﬁciently compute the MAP t-c partition for each feature an d relation. We ﬁnd the MAP tree ﬁrst,
rather than jointly optimizing for both the topology and partitions, because marginalizing over the
t-c partitions produces more robust trees; marginalization has a (Bayesian) ”Occam’s razor ” effect
and helps avoid over ﬁtting. MAP t-c partitions can be comput ed by a straightforward modiﬁcation
of the above dynamic programs, replacing sums with max operations and maintaining a list of nodes
representing the MAP t-c partition at each node in the tree.

We chose to implement global search by building a Markov chain Monte Carlo (MCMC) algorithm
with the posterior as the stationary distribution and keeping track of the best tree as the chain mixes.
For all the results in this paper, we ﬁxed the hyperparameter s of all beta distributions to γ = 0.5
(i.e. the asymptotically least informative prior) and report the (empirical) MAP tree and MAP t-c
partitions conditioned on the tree. The MCMC algorithm searches for the MAP tree by cycling
through three Metropolis-Hastings (MH) moves adapted from [14]:

i. Subtree Pruning and Regrafting: Choose a node n uniformly at random (except the root).
Choose a non-descendant node m. Detach n from its parent and collapse the parent (remove

node, attaching the remaining child to the parent’s parent and adding the parent’s weight to
the child’s). Sample u ∼ Uniform(0, 1) and then insert a new node m′ between m and its
parent. Attach n to m′ , set wm′ := (1 − u)wm and set wm := uwm .
ii. Edge Weight Adjustment: Choose a node n uniformly at random (including the root) and
propose a new weight wn (e.g. let x be Normal(log(wt ), 1) and let new weight be ex ).
iii. Subtree Swapping: Choose a node n uniformly at random (except the root). Choose another
node n′ such that neither n nor n′ is a descendant of the other, and swap n and n′ .

The ﬁrst two moves sufﬁce to make the chain ergodic; subtree s wapping is included to improve
mixing. The ﬁrst and last moves are symmetric. We initialize d the chain on a random tree with
weights set to one, ran the chain for approximately one million iterations and assessed convergence
by comparing separate chains started from multiple random initial states.

2.2 Related Work

There are several methods that discover hierarchical structure in feature data. Hierarchical clustering
[4] has been successfully used for analyzing both biological data [18] and psychological data, but
cannot learn the annotated hierarchies that we consider. Bayesian hierarchical clustering (BHC) [6]
is a recent alternative which constructs a tree as a byproduct of approximate inference in a ﬂat
clustering model, but lacks any notion of annotations. It is possible that a BHC-inspired algorithm
could be derived to ﬁnd approximate MAP annotated hierarchi es. Our model for feature data is most
closely related to methods for Bayesian phylogenetics [14]. These methods typically assume that
features are generated directly by a stochastic process over a tree. Our model adds an intervening
layer of abstraction by assuming that partitions are generated by a stochastic process over a tree, and
that features are generated from these partitions. By introducing a partition for each feature, we gain
the ability to annotate a hierarchy with the levels most relevant to each feature.

There are several methods for discovering hierarchical structure in relational data [5, 13], but none
of these methods provides a general purpose solution to the problem we consider. Most of these
methods take a single relation as input, and assume that the hierarchy captures an underlying com-
munity structure: in other words, objects that are often paired in the input are assumed to lie nearby
in the tree. Our approach handles multiple relations simultaneously, and allows a more ﬂexible map-
ping between each relation and the underlying hierarchy. Different relations may depend on very
different regions of the hierarchy, and some relations may establish connections between categories
that are quite distant in the tree (see Figure 4).

Many non-hierarchical methods for relational clustering have also been developed [10, 16, 17]. One
family of approaches is based on the stochastic blockmodel [15], of which the In ﬁnite Relational
Model (IRM) [9] is perhaps the most ﬂexible. The IRM handles m ultiple relations simultaneously,
and does not assume that each relation has underlying community structure. The IRM, however,
does not discover hierarchical structure; instead it partitions the objects into a set of non-overlapping
categories. Our relational model is an extension of the blockmodel that discovers a nested set of
categories as well as which categories are useful for understanding each relation in the data set.

3 Results
We applied our model to three problems inspired by tasks that human learners are required to solve.
Our ﬁrst application used data collected in a feature-listi ng task by Cree and McRae [2]. Participants
in this task listed the features that came to mind when they thought about a given object: when asked
to think about a lemon, for example, subjects listed features like “yellow,”
“sour,” and “grows on
trees.” 1 We analyzed a subset of the full data set including 60 common objects and the 100 features
most commonly listed for these objects. The 60 objects are shown in Figure 2, and were chosen to
represent four domains: animals, food, vehicles and tools.

Figure 2 shows the MAP tree identiﬁed by our algorithm. The mo del discovers the four domains
as well as superordinate categories (e.g. “living things”,
including fruits, vegetables, and animals)
and subordinate categories (e.g. “wheeled vehicles”). Fig ure 2 also shows MAP partitions for 10

1Note that some of the features are noisy — according to these d ata, onions are not edible, since none of the
participants chose to list this feature for onion.

e
e
t
n
e
e
e
e
i
u
p
g
o
l
n
n
p
l
l
p
h
r
t
o
s
e
y
l
p
r
a
o
n
m
i
i
e
i
m
n
p
r
r
r
s
t
c
f
r
p
r
r
a
a
e
a
e
r
b
d
i
o
u
a
e
g
r
e
a
d
a
t
r
p
t
g
m
s
s
e
r
h
e
l
a
k
l
r
t
i
o
l
c
e
o
e
b
e
e
a
n
l
e
t
r
a
r
n
w
o
c
x
c
c
e
e
p
v
u
r
e
o
s
w
e
m
r
n
r
o
m
r
a
n
a
h
e
a
l
a
n
o
i
c
i
g
s
k
i
h
a
l
t
e
p
v
m
b
m
p
h
h
u
s
a
c
r
r
i
w
a
i
s
c
r
t
r
w
a
c
a
s
d
m
o
s
h
h
w
r
e
o
c
e
g
t
r
d
c
e
s
l
s

r
w
t
e
g
k
s
t
r
p
p
l
n
r
k
e
n
n
l
e
a
a
n
e
e
a
a
c
u
s
i
e
e
e
t
c
t
r
p
o
a
n
e
s
i
o
p
g
r
w
c
e
e
r
e
h
e
h
e
u
e
r
c
e
b
u
e
e
k
i
r
c
v
u
i
l
i
i
o
n
k
h
d
a
c
c
j
p
l
s
r
o
t
t
i
l
i
d
h
j
u
o
p
c
t
h
b
c
i
a
y
s
r
l
r
r
s
o
y
q
m
t
o
i
r
c
a
y
h
a
c
d
s
c
r
m
c
o
b
i
i
r
l
t
l
e
t
b
e
o
h
u
e
m
s
h
w

Food

Tools

Vehicles

Animals

a tool
an animal
made of metal
is edible
has a handle
is juicy
is fast
eaten in salads
is white
has 4 wheels
has 4 legs
Figure 2: MAP tree recovered from a data set including 60 objects from four domains. MAP partitions for
several features are shown: the model discovers, for example, that “is juicy” is associated with only one part of
the tree. The weight of each edge in the tree is proportional to its vertical extent.

y
t
i
l
a
m
r
o
n
b
A
 
d
e
r
i
u
q
c
A

y
t
i
l
a
m
r
o
n
b
A
 
l
a
t
i
n
e
g
n
o
C

n
o
i
t
c
n
u
F
 
l
l
e
C

n
o
i
t
c
n
u
F
 
n
a
g
r
O

e
m
o
r
d
n
y
S
 
r
o
 
e
s
a
e
s
i
D

n
o
i
t
c
n
u
F
 
c
i
g
o
l
o
i
s
y
h
P

n
o
i
t
c
n
u
f
s
y
D
 
l
l
e
C

n
o
i
t
c
n
u
F
 
c
i
g
o
l
o
h
t
a
P

l
l
e
C

e
u
s
s
i
T

e
r
u
t
c
u
r
t
S
 
l
a
c
i
m
o
t
a
n
A

d
r
i
B

t
n
a
l
P

l
a
m
i
n
A

l
a
m
m
a
M

e
r
u
d
e
c
o
r
P
 
c
i
t
u
e
p
a
r
e
h
T

e
r
u
d
e
c
o
r
P
 
y
r
o
t
a
r
o
b
a
L

t
l
u
s
e
R
 
y
r
o
t
a
r
o
b
a
L

e
r
u
d
e
c
o
r
P
 
c
i
t
s
o
n
g
a
i
D

g
n
i
d
n
i
F

m
o
t
p
m
y
S
 
r
o
 
n
g
i
S

s
s
e
c
o
r
P
 
l
a
r
u
t
a
N

s
s
e
c
o
r
P
 
d
e
s
u
a
c
−
n
a
m
u
H

c
i
t
o
i
b
i
t
n
A

e
n
o
m
r
o
H

e
m
y
z
n
E

d
i
o
r
e
t
S

e
t
a
r
d
y
h
o
b
r
a
C

d
i
p
i
L

d
i
c
A
 
o
n
i
m
A

Diseases

Chemicals

analyzes
affects
process of
causes
causes (IRM)
Figure 3: MAP tree recovered from 49 relations between entities in a biomedical data set. Four relations are
shown (rows and columns permuted to match in-order traversal of the MAP tree). Consider the circled subset of
the t-c partition for causes. This block captures the knowledge that “chemicals”
cause “diseases.” The Inﬁnite
Relational Model (IRM) does not capture the appropriate structure in the relation cause because it does not
model the latent hierarchy, instead choosing a single partition to describe the structure across all relations.

representative features. The model discovers that some features are associated only with certain
parts of the tree: “is juicy ” is associated with the fruits, a nd “is metal” is associated with the man-
made items. Discovering domains is a fundamental cognitive problem that may be solved early
in development [11], but that is ignored by many cognitive models, which consider only carefully
chosen data from a single domain (e.g. data including only animals and only biological features). By
organizing the 60 objects into domains and identifying a subset of features that are associated with
each domain, our model begins to suggest how infants may parse their environment into coherent
domains of objects and features.

Our second application explores the acquisition of ontological knowledge, a problem that has been
previously discussed by Keil [7]. We demonstrate that our model discovers a simple biomedical
ontology given data from the Uniﬁed Medical Language System (UMLS) [12]. The full data set in-
cludes 135 entities and 49 binary relations, where the entities are ontological categories like ‘Sign or
Symptom’, ‘Cell’, and ‘Disease or Syndrome,’ and the relations include verbs like causes, analyzes
and affects. We applied our model to a subset of the data including the 30 entities shown in Figure 3.

1
F
1
1
1
1
1
1
1
1Y
1
1
F
M
M
M
F
F
F
F
F
F
O
O
O
O
Y
Y
Y
O
O
O
1
M
O

3
1
F
3
M
Y
F
Y
Y
1
1
1
M
M
M
Y
Y
Y

3
3
3
3
3
M
F
F
3
F
3
3
F
O
Y
F
O
O
F
M
3
Y
O
O
M
3
O
3
M
Y
M
Y
3
Y
M
Y

4
M
4
3
3
M
O
M
M
4
O
O
O
F
4
4
4
4
4
4
4
O
F
F
F
F
F
F
F
O
O
Y
Y
Y
Y
O

2
M
O

2
M
2
2
O
F
F
2
2
2
2O
F
Y
F
M
O
2
F
O
M
Y
O
Y

2
2
F
F
Y
Y

2
F
Y

4
2
2
4
4
M
2
2
M
M
M
M
M
M
O
Y
Y
Y
O
O
O
4
4
4
M
M
M
Y
Y
Y

Section 1

Section 3

Section 4

Section 2

Agngiya
Adiaya
Umbaidya
Anowadya
Anowadya (IRM)
Figure 4: MAP tree recovered from kinship relations between 64 members of the Alyawarra tribe. Individuals
have been labelled with their age, gender and kinship section (e.g. “YF1” is a young female from section 1).
MAP partitions are shown for four representative relations: the model discovers that different relations depend
on the tree in very different ways; hierarchical structure allows for a compact representation (c.f. IRM).

The MAP tree is an ontology that captures several natural groupings, including a category for “living
things” (plant, bird, animal and mammal), a category for “ch emical substances” (amino acid, lipid,
antibiotic, enzyme etc.) and a category for abnormalities. The MAP partitions for each relation
identify the relevant categories in the tree relatively cleanly: the model discovers, for example, that
the distinction between “living things” and “abnormalitie
s” is irrelevant to the ﬁrst place of the
relation causes, since neither of these categories can cause anything (according to the data set). This
distinction, however, is relevant to the second place of causes: substances can cause abnormalities
and dysfunctions, but cannot cause “living things”. Note that the MAP partitions for
causes and
analyzes are rather different: one of the reasons why discovering separate t-c partitions for each
relation is important is that different relations can depend on very different parts of an ontology.

Our third application is inspired by the problem children face when learning the kinship structure
of their social group. This problem is especially acute for children growing up in Australian tribes,
which have kinship systems that are more complicated in many ways than Western kinship systems,
but which nevertheless display some striking regularities. We focus here on data from the Alyawarra
tribe [3]. Denham [3] collected a large data set by asking 104 tribe members to provide kinship terms
for each other. Twenty-six different terms were mentioned in total, and four of them are represented
in Figure 4. More than one kinship term may describe the relationship between a pair of individuals
— since the data set includes only one term per pair, some of th
e zeros in each matrix represent
missing data rather than relationships that do not hold. For simplicity, however, we assume that
relationships that were never mentioned do not exist.

The Alyawarra tribe is divided into four kinship sections, and these sections are fundamental to
the social structure of the tribe. Each individual, for instance, is permitted only to marry individuals
from one of the other sections. Whether a kinship term applies between a pair of individuals depends
on their sections, ages and genders [3, 8]. We analyzed a subset of the full data set including 64
individuals chosen to equally represent all four sections, both genders, and people young and old.
The MAP tree divides the individuals perfectly according to kinship section, and discovers additional
structure within each section. Group three, for example, is split by age and then by gender. The MAP
partitions for each relation indicate that different relations depend very differently on the structure
of the tree. Adiadya refers to a younger member of one’s own kinship section. The MAP partition
for this relation contains ﬁne-level structure only along t he diagonal, indicating that the model has
discovered that the term only applies between individuals from the same kinship section. Umbaidya
can be used only between members of sections 1 and 3, and members of sections 2 and 4. Again
the MAP partition indicates that the model has discovered this structure. In some places the MAP
partitions appears to over ﬁt the data: the partition for Umbaidya, for example, appears to capture
some of the noise in this relation. This result may re ﬂect the fact that our generative process is not
quite right for these data: in particular, it does not capture the idea that some of the zeroes in each
relation represent missing data.

4 Conclusions
We developed a probabilistic model that assumes that features and relations are generated over an
annotated hierarchy, and showed how this model can be used to recover annotated hierarchies from
raw data. Three applications of the model suggested that it is able to recover interpretable structure
in real-world data, and may help to explain the computational principles which allow human learners
to acquire hierarchical representations of real-world domains.

Our approach opens up several avenues for future work. A hierarchy speciﬁes a set of categories,
and annotations indicate which of these categories are important for understanding speciﬁc features
and relations. A natural extension is to learn sets of categories that possess other kinds of structure,
such as factorial structure [17]. For example, the kinship data we analyzed may be well described
by three sets of overlapping categories where each individual belongs to a kinship section, a gender,
and an age group. We have already extended the model to handle continuous data and can imag-
ine other extensions, including higher-order relations, multiple trees, and relations between distinct
sets of objects (e.g. given information, say, about the book-buying habits of a set of customers, this
extension of our model could discover a hierarchical representation of the customers and a hierar-
chical representation of the books, and discover the categories of books that tend to be preferred by
different kinds of customers). We are also actively exploring variants of our model that permit accu-
rate online approximations for inference; e.g., by placing an exchangeable prior over tree structures
based on a Polya-urn scheme, we can derive an efﬁcient partic le ﬁlter.

We have shown that formalizing the intuition behind annotated hierarchies in terms of a prior on
trees and partitions and a noise-robust likelihood enabled us to discover interesting structure in real-
world data. We expect a fruitful area of research going forward will involve similar marriages be-
tween intuitions about structured representation from classical AI and cognitive science and modern
inferential machinery from Bayesian statistics and machine learning.

References
[1] A. M. Collins and M. R. Quillian. Retrieval Time from Semantic Memory. JVLVB, 8:240–248, 1969.
[2] G. Cree and K. McRae. Analyzing the factors underlying the structure and computation of the meaning
of chipmunk, chisel, cheese, and cello (and many other concrete nouns). JEP Gen., 132:163–201, 2003.
[3] W. Denham. The detection of patterns in Alyawarra nonverbal behaviour. PhD thesis, U. of Wash., 1973.
[4] R. O. Duda and P. E. Hart. Pattern Classi ﬁcation and Scene Analaysis . Wiley, 2001.
[5] M. Girvan and M. E. J. Newman. Community structure in social and biological networks. Proceedings
of the National Academy of Sciences, 99(12):7821–7826, 2002.
[6] K. Heller and Z. Ghahramani. Bayesian Hierarchical Clustering. In ICML, 2005.
[7] F. C. Keil. Semantic and Conceptual Development. Harvard University Press, Cambridge, MA, 1979.
[8] C. Kemp, T. L. Grifﬁths, and J. B. Tenenbaum. Discovering Latent Classes in Relational Data. Technical
Report AI Memo 2004-019, MIT, 2004.
[9] C. Kemp, J. B. Tenenbaum, T. L. Grifﬁths, T. Yamada, and N. Ueda. Learning systems of concepts with
an inﬁnite relational model. In AAAI, 2006.
[10] J. Kubica, A. Moore, J. Schneider, and Y. Yang. Stochastic link and group detection. In NCAI, 2002.
[11] J. M. Mandler and L. McDonough. Concept formation in infancy. Cog. Devel., 8:291–318, 1993.
[12] A. T. McCray. An upper level ontology for the biomedical domain. Comp. Func. Genom., 4:80–84, 2001.
[13] J. Neville, M. Adler, and D. Jensen. Clustering relational data using attribute and link information. In
Proc. of the Text Mining and Link Analysis Workshop, IJCAI, 2003.
[14] D. L. Swofford, G. J. Olsen, P. J. Waddell, and D. M. Hillis. Phylogenetic inference. Molecular System-
atics, 2nd. edition, 1996.
[15] Y. J. Wang and G. Y. Wong. Stochastic blockmodels for directed graphs. JASA, 82:8–19, 1987.
[16] S. Wasserman and K. Faust. Social network analysis: Methods and applications. Cambridge Press, 1994.
[17] A. P. Wolfe and D. Jensen. Playing multiple roles: discovering overlapping roles in social networks. In
Proc. of the Workshop on statistical relational learning and its connections to other ﬁelds, ICML , 2004.
[18] K. Y. Yeung, M. Medvedovic, and R. E. Bumgarner. Clustering gene-expression data with repeated
measurements. Genome Biology, 2003.

