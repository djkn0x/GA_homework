Unsupervised Regression with Applications to
Nonlinear System Identiﬁcation

Ali Rahimi
Intel Research Seattle
Seattle, WA 98105
ali.rahimi@intel.com

Ben Recht
California Institute of Technology
Pasadena, CA 91125
brecht@ist.caltech.edu

Abstract

We derive a cost functional for estimating the relationship between high-
dimensional observations and the low-dimensional process that generated them
with no input-output examples. Limiting our search to invertible observation
functions confers numerous beneﬁts, including a compact representation and no
suboptimal local minima. Our approximation algorithms for optimizing this cost
functional are fast and give diagnostic bounds on the quality of their solution. Our
method can be viewed as a manifold learning algorithm that utilizes a prior on the
low-dimensional manifold coordinates. The beneﬁts of taking advantage of such
priors in manifold learning and searching for the inverse observation functions
in system identiﬁcation are demonstrated empirically by learning to track mov-
ing targets from raw measurements in a sensor network setting and in an RFID
tracking experiment.

1 Introduction

Measurements from sensor systems typically serve as a proxy for latent variables of interest. To
recover these latent variables, the parameters of the sensor system must ﬁrst be determined. When
pairs of measurements and their corresponding latent variables are available, fully supervised re-
gression techniques may be applied to learn a mapping between latent states and measurements.
In many applications, however, latent states cannot be observed and only a diffuse prior on them is
available. In such cases, marginalizing over the latent variables and searching for the model parame-
ters using Expectation Maximization (EM) has become a popular approach [3, 9, 19]. Unfortunately,
such algorithms are prone to local minima and require very careful initialization in practice.
Using a simple change-of-variable model, we derive an approximation algorithm for the Unsuper-
vised Regression problem – estimating the nonlinear relationship between latent-states and their
observations when no example pairs are available, when the observation function is invertible, and
when the measurement noise is small. Our method is not susceptible to local minima and provides a
guarantee on the quality of the recovered observation function. We identify conditions under which
our estimate of the mapping is asymptotically consistent and empirically evaluate the quality of our
solutions and their stability under variations of the prior. Because our algorithm takes advantage of
an explicit prior on the latent variables, it recovers latent variables more accurately than manifold
learning algorithms when applied to similar tasks.
Our method may be applied to estimate the observation function in nonlinear dynamical systems
by enforcing a Markovian dynamics prior over the latent states. We demonstrate this approach
to nonlinear system identiﬁcation by learning to track a moving object in a ﬁeld of completely
uncalibrated sensor nodes whose measurement functions are unknown. Given that the object moves
smoothly over time, our algorithm learns a function that maps the raw measurements from the sensor
network to the target’s location. In another experiment, we learn to track Radio Frequency ID (RFID)

tags given a sequence of voltage measurements induced by the tag in a set of antennae . Given only
these measurements and that the tag moves smoothly over time, we can recover a mapping from
the voltages to the position of the tag. These results are surprising because no parametric sensor
model is available in either scenario. We are able to recover the measurement model up to an afﬁne
transform given only raw measurement sequences and a diffuse prior on the state sequence.

2 A diffeomorphic warping model for unsupervised regression
We assume that the set X = {xi }1···N of latent variables is drawn (not necessarily iid) from a known
distribution, pX (X) = pX (x1 , · · · , xN ). The set of measurements Y = {yi }1···N is the output of
an unknown invertible nonlinearity applied to each latent variable, yi = f0 (xi ). We assume that
observations, yi ∈ RD , are higher dimensional than latent variables xi ∈ Rd . Computing a MAP
estimate of f0 requires marginalizing over X and maximizing over f . EM, or some other form of
coordinate ascent on a Jensen bound of the likelihood, is a common way of estimating the parameters
of this model, but such methods suffer from local minima.
Because we have assumed that f0 is invertible and that there is no observation noise, this process
describes a change of variables. The true distribution pY (Y) over Y can be computed in closed form
using a generalization of the standard change of variables formula (see [14, thm 9.3.1] and [7, chap
0 (yi )(cid:1) (cid:19)− 1
(cid:18)
NY
∇f (cid:0)f −1
0 (yi )(cid:1)0 ∇f (cid:0)f −1
11]):
2
i=1
(1)
The determinant corrects the warping of each inﬁnitesimal volume element around f −1
0 (yi ) by ac-
counting for the stretching induced by the nonlinearity. The change of variables formula immedi-
ately yields a likelihood over f , circumventing the need for integrating over the latent variables.
We assume f0 diffeomorphically maps a ball in Rd containing the data onto its image. In this case,
there exists a function g deﬁned on an open set containing the image of f such that g(f (x)) = x
and ∇g∇f = I for all x in the open set [5]. Consequently, we can substitute g for f −1 in (1) and,
taking advantage of the identity det(∇f 0∇f )−1 = det ∇g∇g 0 , write its log likelihood as
NX
1
log det (∇g(yi )∇g(yi )0 ) .
2
i=1

0 (y1 ), · · · , f −1
pY (Y) = pY (Y ; f0 ) = pX (f −1
0 (yN ))

lY (Y ; g) = log pY (Y ; g) = log pX (g(y1 ), . . . , g(yN )) +

det

.

(2)

For many common priors pX , the maximum likelihood g yields an asymptotically consistent es-
timate of the true distribution pY . When certain conditions on pX are met (including stationarity,
ergodicity, and k th-order Markov approximability), a generalized version of the Shannon-McMillan-
Breiman theorem [1] guarantees that log pY (Y ; g) asymptotically converges to the relative entropy
rate between the true pY (Y) and pY (Y ; g). This quantity is maximized when these two distribu-
tions are equal. Therefore, if the true pY follows the change of variable model (1), the recovered g
converges to the true f −1
in the sense that they both describe a change of variable from the prior
0
distribution pX to the distribution pY .
Note that although our generative model assumes no observation noise, some noise in Y can be
tolerated if we constrain our search over smooth functions g . This way, small perturbations in y due
to observation noise produce small perturbations in g(y).

3 Approximation algorithms for ﬁnding the inverse mapping
PN
We constrain our search for g to a subset of smooth functions by requiring that g have a ﬁnite
representation as a weighted sum of positive deﬁnite kernels k centered on observed data, g(y) =
i=1 cik(y , yi ), with the weight vectors ci ∈ Rd . Accordingly, applying g to the set of observations
gives g(Y) = CK, where C = [ c1 ···cN ] and K is the kernel matrix with Kij = k(yi , yj ). In
addition, ∇g(y) = C∆(y), where ∆(y) is an N × D matrix whose ith row is ∂ k(yi ,y)
. We tune
∂ y
the smoothness of g by regularizing (2) with the RKHS norm [17] of g . This norm has the form
kgk2
k = tr CKC0 , and the regularization parameter is set to λ
2 .

(3)

0
−vec (KC0 )

log det C∆(yi )∆(yi )0C0 ,

ΩXvec (KC0 ) − λtrCKC0 +

For simplicity, we require pX to be a Gaussian with mean zero and inverse covariance ΩX , but we
note our methods can be extended to any log-concave distribution. Substituting into (2) and adding
NX
the smoothness penalty on g , we obtain:
max
C
i=1
where the vec (·) operator stacks up the columns of its matrix argument into a column vector.
Equation (3) is not concave in C and is likely to be hard to maximize exactly. This is because
log det(A0A) is not concave for A ∈ Rd×D . Since the cost is non-concave, gradient descent
methods may converge to local minima. Such local minima, in addition to the burdensome time and
storage requirements, rule out descent strategies for optimizing (3).
Our ﬁrst algorithm for approximately solving this optimization problem constructs a semideﬁnite
relaxation using a standard approach that replaces outer products of vectors with positive deﬁnite
0 (cid:21)(cid:19)
(cid:18)(cid:20)
0(cid:17)
(cid:16)
NX
matrices. Rewrite (3) as
− tr
Mvec (C0 ) vec (C0 )
i vec (C0 ) vec (C0 )
max
+
tr Jkl
log det
C
i=1
i = Elk ⊗ ∆(yi )∆(yi )0
M = (Id ⊗ K)ΩX (Id ⊗ K) + λ(Id ⊗ K)
Jkl
,
where the k lth entry of the matrix argument of the logdet is as speciﬁed, and the matrix Eij is zero
NX
log det (cid:0)(cid:2)tr Jkl
i Z(cid:3)(cid:1) ,
everywhere except for 1 in its ij th entry. This optimization is equivalent to
i=1
subject to the additional constraint that rank(Z) = 1. Dropping the rank constraint yields a concave
relaxation for (3). Standard interior point methods [20] or subgradient methods [2] can efﬁciently
compute the optimal Z for this relaxed problem. A set of coefﬁcients C can then be extracted from
the top eigenvectors of the optimal Z, yielding an approximate solution to (3). Since (6) without
the rank constraint is a relaxation of (3), the optimum of (6) is an upper bound on that of (3). Thus
we can bound the difference in the value of the extracted solution and that of the global maximum
of (3). As we will see in the following section, this method produces high quality solutions for a
diverse set of learning problems.
In practice, standard algorithms for (6) run slowly for large data sets, so we have developed an
intuitive algorithm that also provides good approximations and runs much more quickly. The non-
concave logdet term serves to prevent the optimal solution of (2) from collapsing to g(y) = 0,
since X = 0 is the most likely setting for the zero-mean Gaussian prior pX . To circumvent the
non-concavity of the logdet term, we replace it with constraints requiring that the sample mean and
covariance of g(Y) match the expected mean and covariance of the random variables X. These
moment constraints prevent the optimal solution from collapsing to zero while remaining in the
typical set of pX . The expected covariance of X, denoted by ¯ΛX , can be computed by averaging
the block diagonals of Ω−1
X . However, the particular choice of ¯ΛX only inﬂuences the ﬁnal solution
up to a scaling and rotation on g , so in practice, we set it to the identity matrix. We thus obtain the
following optimization problem:

− tr (MZ) +

max
Z(cid:23)0

(6)

(4)

(5)

min
C

0
vec (KC0 )
ΩXvec (KC0 ) + λtrCKC0
CK(CK)0 = ¯ΛX

s.t.

1
N
1
N
where 1 is a column vector of 1s. This optimization problem searches for a g that transforms
observations into variables that are given high probability by pX and match its stationary statistics.
This is a quadratic minimization with a single quadratic constraint and, after eliminating the linear
constraints with a change of variables, can be solved as a generalized eigenvalue problem [4].

CK1 = 0,

(9)

(8)

(7)

4 Related Work

Manifold learning algorithms and unsupervised nonlinear system identiﬁcation algorithms solve
variants of the unsupervised regression problem considered here.
Our method provides a statistical model that augments manifold learning algorithms with a prior on
latent variables. Our spectral algorithm from Section 3 reduces to a variant of KPCA [15] when X
are drawn iid from a spherical Gaussian. By adopting a nearest-neighbors form for g instead of the
RBF form, we obtain an algorithm that is similar to embedding step of LLE [12, chap 5]. In addition
to our use of dynamics, a notable difference between our method and principal manifold methods
[16] is that instead of learning a mapping from states to observations, we learn mappings from
observations to states. This reduces the storage and computational requirements when processing
high-dimensional data. As far as we are aware, in the manifold learning literature, only Jenkins and
Mataric [6] explicitly take temporal coherency into account, by increasing the afﬁnity of temporally
adjacent points and applying Isomap [18].
State-of-the-art nonlinear system identiﬁcation techniques seek to recover all the parameters of a
continuous hidden Markov chain with nonlinear state transitions and observation functions given
noisy observations [3, 8, 9, 19]. Because these models are so rich and have so many unknowns, these
algorithms resort to coordinate ascent (for example, via EM), making them susceptible to local min-
ima. In addition, each iteration of coordinate ascent requires some form of nonlinear smoothing
over the latent variables, which is itself both computationally costly and becomes prone to local
minima when the estimated observation function becomes non-invertible during the iterations. Fur-
ther, because mappings from low-dimensional to high-dimensional vectors require many parameters
to represent, existing approaches tend to be unsuitable for large-scale sensor network or image anal-
ysis problems. Our algorithms do not have local minima and represent the more compact inverse
observation function where high-dimensional observations appear only in pairwise kernel evalua-
tions.
Comparisons with a semi-supervised variant of these algorithms [13] show that weak priors on the
latent variables are extremely informative and that additional labeled data is often only necessary to
ﬁx the coordinate system.

5 Experiments

The following experiments show that latent states and observation functions can be accurately and
efﬁciently recovered up to a linear coordinate transformation given only raw measurements and a
generic prior over the latent variables. We compare against various manifold learning and nonlinear
system identiﬁcation algorithms. We also show that our algorithm is robust to variations in the
choice of the prior.
qPN
As a measure of quality, we report the afﬁne registration error, the average residual per data point
after registering the recovered latent variables with their ground truth values using an afﬁne trans-
t + bk2
t=1 kAxt − x0
formation: err = minA,b
2 , where x0
t is the ground truth setting for xt .
1
N
All of our experiments use a spherical Gaussian kernel. To deﬁne the Gaussian prior pX , we start
with a linear Gaussian Markov chain st = Ast−1 + ωt , where A and the covariance of ω are block
diagonal and deﬁne d Markov chains that evolve independently from each other according to New-
tonian motion. The latent variables xt extract the position components of st . The inverse covariance
matrix corresponding to this process can be obtained in closed form. More details and additional
experiments can be found in [12].
We begin with a low-dimensional data set to simplify visualization and comparison to systems
that do not scale well with the dimensionality of the observations. Figure 1(b) shows the embed-
ding of a 1500 step 2D random walk shown in Figure 1(a) into R3 by the function f (x, y) =
(x, y cos(2y), y sin(2y)). Note that the 2D walk was not generated by a linear Gaussian model, as
it bounces off the edges of its bounding box. Lifted points were passed to our algorithm, which
returned the 2D variables shown in Figure 1(c). The true 2D coordinates are recovered up to a scale,
a ﬂip, and some shrinking in the lower left corner. Therefore the recovered g is close the inverse
of the original mapping, up to a linear transform. Figure 1(d) shows states recovered by the algo-
rithm of Roweis and Ghahramani [3]. Smoothing with the recovered function simply projects the

(a)

(d)

(b)

(e)

(c)

(f)

Figure 1: (a) 2D ground truth trajectory. Brighter colors indicate greater distance to the origin. (b) Embedding
of the trajectory into R3 . (c) Latent variables are recovered up to a linear transformation and minor distortion.
Roweis-Ghahramani (d), Isomap (e), and Isomap+temporal coherence (f) recovered low-dimensional coordi-
nates that exhibit folding and other artifacts that cannot be corrected by a linear transformation.

observations without unrolling the roll. The joint-max version of this algorithm took about an hour
to converge on a 1Ghz Pentium III and converges only when started at solutions that are sufﬁciently
close to the true solution. Our spectral algorithm took about 10 seconds. Isomap (Figure 1(e)) per-
forms poorly on this data set due to the low sampling rate on the manifold and the fact that the true
mapping f is not isometric. Including temporal neighbors into Isomap’s neighborhood structure (as
per ST-Isomap) creates some folding, and the true underlying walk is not recovered (Figure 1(f)).
KPCA (not shown) chooses a linear projection that simply eliminates the ﬁrst coordinate. We found
the optimal parameter settings for Isomap, KPCA, and ST-Isomap by a ﬁne grid search over the
parameter space of each algorithm.
The upper bound on the log-likelihood returned by the relaxation (6) serves as a diagnostic on the
quality of our approximations. This bound was −3.9 × 10−3 for this experiment. Rounding the
result of the relaxation returned a g with log likelihood −5.5 × 10−3 . The spectral approximation
(7) also returned a solution with log likelihood −5.5 × 10−3 , conﬁrming our experience that these
algorithms usually return similar solutions. For comparison, log-likelihood of KPCA’s solution was
−1.69 × 10−2 , signiﬁcantly less likely than our solutions, or the upper bound.

5.1 Learning to track in an uncalibrated sensor network

We consider an artiﬁcial distributed sensor network scenario where many sensor nodes are deployed
randomly in a ﬁeld in order to track a moving target (Figure 2(a)). The location of the sensor
nodes is unknown, and the sensors are uncalibrated, so that it is not known how the position of the
target maps to the reported measurements. This situation arises when it is not feasible to calibrate
each sensor prior to deployment or when variations in environmental conditions affect each sensor
differently. Given only the raw measurements produced by the network from watching a smoothly
moving target, we wish to learn a mapping from these measurements to the location of the target,
even though no functional form for the measurement model is available. A similar problem was
considered by [11], who sought to recover the location of sensor nodes using off-the-shelf manifold
learning algorithms.
Each latent state xt is the unknown position of the target at time t. The unknown function f (xt )
gives the set of measurements yt reported by the sensor network at time t. Figure 2(b) shows the
time series of measurements from observing the target. In this case, measurements were generated
by having each sensor s report its true distance ds
t to the target at time t and passing it through a
random nonlinearity of the form αs exp(−β sds
t ). Note that only f , not the measurement function
of each sensor, needs be invertible. This is equivalent to requiring that a memoryless mapping from
measurements to positions must exist.

0246−505−6−5−4−3−2−101234(a)

(d)

(b)

(e)

(c)

(f)

Figure 2: (a) A target followed a smooth trajectory (dotted line) in a ﬁeld of 100 randomly placed uncalibrated
sensors with random and unknown observation functions (circle). (b) Time series of measurements produced
by the sensor network in response to the target’s motion. (c) The recovered trajectory given only raw sensor
measurements, and no information about the observation function (other than smoothness and invertibility). It
is recovered up to scaling and a rotation. (d) To test the recovered mapping further, the target was made to
follow a zigzag pattern. (e) Output of g on the resulting measurements. The resulting trajectory is again similar
to the ground truth zigzag, up to minor distortion. (f) The mapping obtained by KPCA cannot recover the
zigzag, because KPCA does not utilize the prior on latent states.

Assuming only that the target vaguely follows linear-Gaussian dynamics, and given only the time se-
ries of the raw measurements from the sensor network, our learning algorithm ﬁnds a transformation
that maps observations from the sensor network to the position of the target up to a linear coordinate
transform (Figure 2(c)). The recovered function g implicitly performs all the triangulation necessary
for recovering the position of the target, even though the position or characteristics of the sensors
were not known a priori. The bottom row of Figure 2 tests the recovered g by applying it to a new
measurement set. To show that this sensor network problem is not trivial, the ﬁgure also shows the
output of the mapping obtained by KPCA.

5.2 Learning to Track with the Sensetable

The Sensetable is a hardware platform for tracking the position of radio frequency identiﬁcation
(RFID) tags. It consists of 10 antennae woven into a ﬂat surface 30 × 30 cm. As an RFID tag moves
along the ﬂat surface, the strength of the RF signal induced by RFID tag in each antenna is reported,
producing a time series of 10 numbers. We wish to learn a mapping from these 10 voltage measure-
ments to the 2D position of the RFID tag. Previously, such a mapping was recovered by hand, by
meticulous physical modeling of this system, followed by trial-and-error to reﬁne these mappings;
a process that took about 3 months in total [10]. We show that it is possible to recover this mapping
automatically, up to an afﬁne transformation, given only the raw time series of measurements gener-
ated by moving the RFID tag by hand on the Sensetable for about 5 minutes. This is a challenging
task because the relationship between the tag’s position and the observed measurements is highly
oscillatory. (Figure 3(a)). Once it is learned, we can use the mapping to track RFID tags. This
experiment serves as a real-world instantiation of the sensor network setup of the previous section
in that each antenna effectively acts as an uncalibrated sensor node with an unknown and highly
oscillatory measurement function.
Figure 3(b) shows the ground truth trajectory of the RFID tag in this data set. Given only the 5
minute-long time series of raw voltage measurements, our algorithm recovered the trajectory shown
in Figure 3(c). These recovered coordinates are scaled down and ﬂipped about both axes as com-
pared to the ground truth coordinates. There is also some additional shrinkage in the upper right
corner, but the coordinates are otherwise recovered accurately, with an afﬁne registration error of
1.8 cm per pixel.
Figure 4 shows the result of LLE, KPCA, Isomap and ST-Isomap on this data set under their best
parameter settings (again found by a grid search on each algorithm’s search space). None of these
algorithms recover low-dimensional coordinates that resemble the ground truth. LLE, in addition to
collapsing the coordinates to one dimension, exhibits severe folding, obtaining an afﬁne registration

−1−0.8−0.6−0.4−0.200.20.40.60.81−1−0.8−0.6−0.4−0.200.20.40.60.811000101010201030104010501060107010801090110000.511.522.5−0.03−0.02−0.0100.010.020.030.040.05−0.04−0.03−0.02−0.0100.010.020.030.04−1−0.8−0.6−0.4−0.200.20.40.60.81−1−0.8−0.6−0.4−0.200.20.40.60.810.0070.0080.0090.010.0110.0120.0130.0140.0150.016−14−13−12−11−10−9−8−7−6−5−4x 10−3−0.027−0.0265−0.026−0.0255−0.025−0.0245−0.024−0.0235−0.023−9−8−7−6−5−4−3−2−10x 10−3(a)

(b)

(c)

Figure 3: (a) The output of the Sensetable over a six second period, while moving the tag from the left edge
of the table to the right edge. The observation function is highly complex and oscillatory. (b) The ground truth
trajectory of the tag. Brighter points have greater ground truth y -value. (c) The trajectory recovered by our
spectral algorithm is correct up to ﬂips about both axes, a scale change, and some shrinkage along the edge.

Figure 4: From left to right, the trajectories recovered by LLE, KPCA, Isomap, ST-Isomap. All of these
trajectories exhibit folding and severe distortions.

error of 8.5 cm. KPCA also exhibited folding and large holes, with an afﬁne registration error of
7.2 cm. Of these, Isomap performed the best with an afﬁne registration error of 3.4 cm, though it
exhibited some folding and a large hole in the center. Isomap with temporal coherency performed
similarly, with a best afﬁne registration error of 3.1 cm. Smoothing the output of these algorithms
using the prior sometimes improves their accuracy by a few millimeters, but more often diminishes
their accuracy by causing overshoots.
To further test the mapping recovered by our algorithm, we traced various trajectories with an RFID
tag and passed the resulting voltages through the recovered g . Figure 5 plots the results (after a
ﬂip about the y-axis). These shapes resemble the trajectories we traced. Noise in the recovered
coordinates is due to measurement noise.
The algorithm is robust to perturbations in pX . To demonstrate this, we generated 2000 random per-
turbations of the parameters of the inverse covariance of X used to generate the Sensetable results,
and evaluated the resulting afﬁne registration error. The random perturbations were generated by
scaling the components of A and the diagonal elements of the covariance of ω over four orders of
magnitude using a log uniform scaling. The afﬁne registration error was below 3.6 cm for 38% of
these 2000 perturbations. Typically, only the parameters of the kernel need to be tuned. In practice,
we simply choose the kernel bandwidth parameter so that the minimum entry in K is approximately
0.1.

Figure 5: Tracking RFID tags using the recovered mapping.

102030405060−100−80−60−40−2002040608010050100150200250300350400450350400450500550600Ground truth−0.03−0.02−0.0100.010.020.03−0.03−0.02−0.0100.010.020.030.04LLE k=15KPCAIsomap K=7−0.04−0.03−0.02−0.0100.010.020.030.04−0.03−0.02−0.0100.010.020.030.04−0.05−0.04−0.03−0.02−0.0100.010.020.03−0.03−0.02−0.0100.010.020.030.04−0.04−0.03−0.02−0.0100.010.020.030.04−0.03−0.02−0.0100.010.020.03−0.06−0.05−0.04−0.03−0.02−0.0100.010.02−0.03−0.02−0.0100.010.020.03−0.03−0.02−0.0100.010.02−0.02−0.015−0.01−0.00500.0050.010.0150.020.025−0.05−0.04−0.03−0.02−0.0100.010.020.030.04−0.03−0.02−0.0100.010.020.030.04−0.05−0.04−0.03−0.02−0.0100.010.020.030.04−0.03−0.02−0.0100.010.020.03−0.05−0.04−0.03−0.02−0.0100.010.020.03−0.03−0.02−0.0100.010.020.036 Conclusions and Future Work

We have shown how to recover the latent variables in a dynamical system given an approximate prior
on the dynamics of these variables and observations of these states through an unknown invertible
nonlinearity. The requirement that the observation function be invertible is similar to the require-
ment in manifold learning algorithms that the manifold not intersect itself. Our algorithm enhances
manifold learning algorithms by leveraging a prior on the latent variables. Because we search for a
mapping from observations to unknown states (as opposed to from states to observations), we can
devise algorithms that are stable and avoid local minima. We applied this methodology to learning
to track objects given only raw measurements from sensors with no constraints on the observation
model other than invertibility and smoothness.
We are currently evaluating various ways to relax the invertibility requirement on the observation
function by allowing invertibility up to a linear subspace. We are also exploring different prior
models, and experimenting with ways to jointly optimize over g and the parameters of pX .

References
[1] P.H. Algoet and T.M. Cover. A sandwich proof of the Shannon-McMillan-Breiman theorem. The Annals
of Probability, 16:899–909, 1988.
[2] Aharon Ben-Tal and Arkadi Nemirovski. Non-euclidean restricted memory level method for large-scale
convex optimization. Mathematical Programming, 102:407–456, 2005.
[3] Z. Ghahramani and S. Roweis. Learning nonlinear dynamical systems using an EM algorithm. In Ad-
vances in Neural Information Processing Systems (NIPS), 1998.
[4] G. Golub and C.F. Van Loan. Matrix Computations. The Johns Hopkins University Press, 1989.
[5] V. Guilleman and A. Pollack. Differential Topology. Prentice Hall, Englewood Cliffs, New Jersey, 1974.
[6] O. Jenkins and M. Mataric. A spatio-temporal extension to isomap nonlinear dimension reduction. In
International Conference on Machine Learning (ICML), 2004.
[7] F. Jones. Advanced Calculus. http://www.owlnet.rice.edu/˜fjones, unpublished.
[8] A. Juditsky, H. Hjalmarsson, A. Benveniste, B. Delyon, L. Ljung, J. Sj ¨oberg, and Q. Zhang. Nonlinear
black-box models in system identiﬁcation: Mathematical foundations. Automatica, 31(12):1725–1750,
1995.
[9] N. D. Lawrence. Gaussian process latent variable models for visualisation of high dimensional data. In
Advances in Neural Information Processing Systems (NIPS), 2004.
[10] J. Patten, H. Ishii, J. Hines, and G. Pangaro. Sensetable: A wireless object tracking platform for tangible
user interfaces. In CHI, 2001.
[11] N. Patwari and A. O. Hero. Manifold learning algorithms for localization in wireless sensor networks. In
International Conference on Acoustics, Speech, and Signal Processing (ICASSP), 2004.
[12] A. Rahimi. Learning to Transform Time Series with a Few Examples. PhD thesis, Massachusetts Institute
of Technology, Computer Science and AI Lab, Cambridge, Massachusetts, USA, 2005.
[13] A. Rahimi, B. Recht, and T. Darrell. Learning appearance manifolds from video. In Computer Vision and
Pattern Recognition (CVPR), 2005.
[14] I. K. Rana. An Introduction to Measure Theory and Integration. AMA, second edition, 2002.
[15] B. Sch ¨olkopf, A. Smola, and K-R. M ¨uller. Nonlinear component analysis as a kernel eigenvalue problem.
Neural Computation, 10:1299–1319, 1998.
[16] A. Smola, S. Mika, B. Schoelkopf, and R. C. Williamson. Regularized principal manifolds. Journal of
Machine Learning, 1:179–209, 2001.
[17] M. Pontil T. Evgeniou and T. Poggio. Regularization networks and support vector machines. Advances
in Computational Mathematics, 2000.
[18] J. B. Tenenbaum, V. de Silva, and J. C. Langford. A global geometric framework for nonlinear dimen-
sionality reduction. Science, 290(5500):2319–2323, 2000.
[19] H. Valpola and J. Karhunen. An unsupervised ensemble learning method for nonlinear dynamic state-
space models. Neural Computation, 14(11):2647–2692, 2002.
[20] Lieven Vandenberghe, Stephen Boyd, and Shao-Po Wu. Determinant maximization with linear matrix
inequality constraints. SIAM Journal on Matrix Analysis and Applications, 19(2):499–533, 1998.

