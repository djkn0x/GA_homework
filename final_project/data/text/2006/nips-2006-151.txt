Robotic Grasping of Novel Objects

Ashutosh Saxena, Justin Driemeyer, Justin Kearns, Andrew Y. Ng
Computer Science Department
Stanford University, Stanford, CA 94305
fasaxena,jdriemeyer,jkearns,angg@cs.stanford.edu

Abstract
We consider the problem of grasping novel objects, speci(cid:2)cally ones that are be-
ing seen for the (cid:2)rst time through vision. We present a learning algorithm that
neither requires, nor tries to build, a 3-d model of the object. Instead it predicts,
directly as a function of the images, a point at which to grasp the object. Our al-
gorithm is trained via supervised learning, using synthetic images for the training
set. We demonstrate on a robotic manipulation platform that this approach suc-
cessfully grasps a wide variety of objects, such as wine glasses, duct tape, mark-
ers, a translucent box, jugs, knife-cutters, cellphones, keys, screwdrivers, staplers,
toothbrushes, a thick coil of wire, a strangely shaped power horn, and others, none
of which were seen in the training set.

1
Introduction
In this paper, we address the problem of grasping novel objects that a robot is perceiving for the (cid:2)rst
time through vision.
Modern-day robots can be carefully hand-programmed or (cid:147)scripted(cid:148) to carry out many complex ma-
nipulation tasks, ranging from using tools to assemble complex machinery, to balancing a spinning
top on the edge of a sword. [15] However, autonomously grasping a previously unknown object still
remains a challenging problem. If the object was previously known, or if we are able to obtain a full
3-d model of it, then various approaches, for example ones based on friction cones, [5] form- and
force-closure, [1] pre-stored primitives, [7] or other methods can be applied. However, in practical
scenarios it is often very dif(cid:2)cult to obtain a full and accurate 3-d reconstruction of an object seen
for the (cid:2)rst time through vision. This is particularly true if we have only a single camera; for stereo
systems, 3-d reconstruction is dif(cid:2)cult for objects without texture, and even when stereopsis works
well, it would typically reconstruct only the visible portions of the object. Finally, even if more
specialized sensors such as laser scanners (or active stereo) are used to estimate the object’s shape,
we would still have only a 3-d reconstruction of the front face of the object.
In contrast to these approaches, we propose a learning algorithm that neither requires, nor tries to
build, a 3-d model of the object. Instead it predicts, directly as a function of the images, a point at
which to grasp the object. Informally, the algorithm takes two or more pictures of the object, and
then tries to identify a point within each 2-d image that corresponds to a good point at which to grasp
the object. (For example, if trying to grasp a coffee mug, it might try to identify the mid-point of the
handle.) Given these 2-d points in each image, we use triangulation to obtain a 3-d position at which
to actually attempt the grasp. Thus, rather than trying to triangulate every single point within each
image in order to estimate depths(cid:151)as in dense stereo(cid:151)we only attempt to triangulate one (or at
most a small number of) points corresponding to the 3-d point where we will grasp the object. This
allows us to grasp an object without ever needing to obtain its full 3-d shape, and applies even to
textureless, translucent or re(cid:3)ective objects on which standard stereo 3-d reconstruction fares poorly.
To the best of our knowledge, our work represents the (cid:2)rst algorithm capable of grasping novel
objects (ones where a 3-d model is not available), including ones from novel object classes, that we
are perceiving for the (cid:2)rst time using vision.

Figure 1: Examples of objects on which the grasping algorithm was tested.

In prior work, a few others have also applied learning to robotic grasping. [1] For example, Jebara et
al. [8] used a supervised learning algorithm to learn grasps, for settings where a full 3-d model of the
object is known. Hsiao and Lozano-Perez [4] also apply learning to grasping, but again assuming a
fully known 3-d model of the object. Piater’s algorithm [9] learned to position single (cid:2)ngers given
a top-down view of an object, but considered only very simple objects (speci(cid:2)cally, square, triangle
and round (cid:147)blocks(cid:148)). Platt et al. [10] learned to sequence together manipulation gaits, but again
assumed a speci(cid:2)c, known, object. There is also extensive literature on recognition of known object
classes (such as cups, mugs, etc.) [14], but this seems unlikely to apply directly to grasping objects
from novel object classes.
To pick up an object, we need to identify the grasping point(cid:151)more formally, a position for the
robot’s end-effector. This paper focuses on the task of grasp identi(cid:2)cation, and thus we will consider
only objects that can be picked up without performing complex manipulation.1 We will attempt to
grasp a number of common of(cid:2)ce and household objects such as toothbrushes, pens, books, mugs,
martini glasses, jugs, keys, duct tape, and markers. (See Fig. 1.)
The remainder of this paper is structured as follows. In Section 2, we describe our learning approach,
as well as our probabilistic model for inferring the grasping point. In Section 3, we describe the
motion planning/trajectory planning (on our 5 degree of freedom arm) for moving the manipulator
to the grasping point. In Section 4, we report the results of extensive experiments performed to
evaluate our algorithm, and Section 5 concludes.

2 Learning the Grasping Point
Because even very different objects can have similar sub-parts, there are certain visual features that
indicate good grasps, and that remain consistent across many different objects. For example, jugs,
cups, and coffee mugs all have handles; and pens, white-board markers, toothbrushes, screw-drivers,
etc. are all long objects that can be grasped roughly at their mid-point. We propose a learning
approach that uses visual features to predict good grasping points across a large range of objects.
Given two (or more) images of an object taken from different camera positions, we will predict the
3-d position of a grasping point. An image is a projection of the three-dimensional world into an
image plane, and does not have depth information. In our approach, we will predict the 2-d location
of the grasp in each image; more formally, we will try to identify the projection of a good grasping
point onto the image plane. If each of these points can be perfectly identi(cid:2)ed in each image, we
can then easily (cid:147)triangulate(cid:148) from these images to obtain the 3-d grasping point. (See Fig. 4a.) In
practice it is dif(cid:2)cult to identify the projection of a grasping point into the image plane (and, if there
are multiple grasping points, then the correspondence problem(cid:151)i.e., deciding which grasping point
in one image corresponds to which point in another image(cid:151)must also be solved). On our robotic
platform, this problem is further exacerbated by uncertainty in the position of the camera when the

1 For example, picking up a heavy book lying (cid:3)at on table might require a sequence of complex manipu-
lations, such as to (cid:2)rst slide the book slightly past the edge of the table so that the manipulator can place its
(cid:2)ngers around the book.

Figure 2: Examples of different edge and texture (cid:2)lters used to calculate the features.

Figure 3: Synthetic images of the objects used for training. The classes of objects used for training
were martini glasses, mugs, teacups, pencils, whiteboard erasers, and books.

images were taken. To address all of these issues, we develop a probabilistic model over possible
grasping points, and apply it to infer a good position at which to grasp an object.2
2.1 Features
In our approach, we begin by dividing the image into small rectangular patches, and for each patch
predict if it is a projection of a grasping point onto the image plane. For this prediction problem,
we chose features that represent three types of local cues: edges, textures, and color. [11, 13] We
compute features representing edges by convolving the intensity channel3 with 6 oriented edge (cid:2)lters
(Fig. 2). Texture information is mostly contained within the image intensity channel, so we apply
9 Laws masks to this channel to compute the texture energy. For the color channels, low frequency
information is most useful to identify grasps; our color features are computed by applying a local
averaging (cid:2)lter (the (cid:2)rst Laws mask) to the 2 color channels. We then compute the sum-squared
energy of each of these (cid:2)lter outputs. This gives us an initial feature vector of dimension 17.
To predict if a patch contains a grasping point, local image features centered on the patch are insuf(cid:2)-
cient, and one has to use more global properties of the object. We attempt to capture this information
by using image features extracted at multiple spatial scales (3 in our experiments) for the patch. Ob-
jects exhibit different behaviors across different scales, and using multi-scale features allows us to
capture these variations. In detail, we compute the 17 features described above from that patch as
well as the 24 neighboring patches (in a 5x5 window centered around the patch of interest). This
gives us a feature vector x of dimension 1 (cid:3) 17 (cid:3) 3 + 24 (cid:3) 17 = 459.
2.2 Synthetic Data for Training
We apply supervised learning to learn to identify patches that contain grasping points. To do so,
we require a labeled training set, i.e., a set of images of objects labeled with the 2-d location of the
grasping point in each image. Collecting real-world data of this sort is cumbersome, and manual
labeling is prone to errors. Thus, we instead chose to generate, and learn from, synthetic data that is
automatically labeled with the correct grasps.
In detail, we generate synthetic images along with correct grasp (Fig. 3) using a computer graph-
ics ray tracer,4 as this produces more realistic images than other simpler rendering methods.5 The
advantages of using synthetic images are multi-fold. First, once a synthetic model of an object has
been created, a large number of training examples can be automatically generated by rendering the
object under different (randomly chosen) lighting conditions, camera positions and orientations, etc.
2An earlier version of this work without the probabilistic model and using simpler learning/inference was
described in [12].
3We use YCbCr color space, where Y is the intensity channel, and Cb and Cr are color channels.
4Ray tracing [3] is a standard image rendering method from computer graphics. It handles many real-world
optical phenomenon such as multiple specular re(cid:3)ections, textures, soft shadows, smooth curves, and caustics.
We used PovRay, an open source ray tracer.
5There is a relation between the quality of the synthetically generated images and the accuracy of the
algorithm. The better the quality of the synthetically generated images and graphical realism, the better the
accuracy of the algorithm. Therefore, we use a ray tracer instead of faster, but cruder, openGL style graphics.
Michels, Saxena and Ng [6] used synthetic openGL images to learn distances in natural scenes. However,
because openGL style graphics have less realism, the learning performance sometimes decreased with added
complexity in the scenes.

In addition, to increase the diversity of the training data generated, we randomized different proper-
ties of the objects such as color, scale, and text (e.g., on the face of a book). The time-consuming
part of synthetic data generation is the creation of the mesh models of the objects. However, there
are many objects for which models are available on the internet, and can be used with only minor
modi(cid:2)cations. We generated 2500 examples from synthetic data, comprising objects from six object
classes (see Figure 3). Using synthetic data also allows us to generate perfect labels for the training
set with the exact location of a good grasp for each object. In contrast, collecting and manually
labeling a comparably sized set of real images would have been extremely time-consuming.

2.3 Probabilistic Model
On our manipulation platform, we have a camera mounted on the robotic arm. (See Fig. 6) When
asked to grasp an object, we command the arm to move the camera to two or more positions, so as
to acquire images of the object from these positions. However, there are inaccuracies in the physical
positioning of the arm, and hence some slight uncertainty in the position of the camera when the
images are acquired. We now describe how we model these position errors. Formally, let C be the
image that would have been taken if the robot had moved exactly to the commanded position and
orientation. However, due to robot positioning error, instead an image ^C is taken from a slightly
different location. Let (u; v) be a 2-d position in image C , and let ( ^u; ^v) be the corresponding image
position in ^C . Thus C (u; v) = ^C ( ^u; ^v), where C (u; v) is the pixel value at (u; v) in image C . The
errors in camera position/pose should usually be small,6 and we model the difference between (u; v)
and ( ^u; ^v) using an additive Gaussian model: ^u = u + (cid:15)u , ^v = v + (cid:15)v , where (cid:15)u ; (cid:15)v (cid:24) N (0; (cid:27)2 ).
For each location (u; v) in an image C , we de(cid:2)ne the class label
to be z (u; v) =
1f(u; v) is the projection of a grasping point into image planeg. (Here, 1f(cid:1)g is the indicator func-
tion; 1fTrueg = 1, 1fFalseg = 0.) For a corresponding location ( ^u; ^v) in image ^C , we similarly
de(cid:2)ne ^z ( ^u; ^v) to indicate whether position ( ^u; ^v) represents a grasping point in the image ^C . Since,
(u; v) and ( ^u; ^v) are corresponding pixels in C and ^C , we assume ^z ( ^u; ^v) = z (u; v). Thus:
(1)
P (z (u; v) = 1jC ) = P ( ^z ( ^u; ^v) = 1j ^C )
(2)
P ((cid:15)u ; (cid:15)v )P ( ^z (u + (cid:15)u ; v + (cid:15)v ) = 1j ^C )d(cid:15)u d(cid:15)v
= R(cid:15)u R(cid:15)v
Here, P ((cid:15)u ; (cid:15)v ) is the (Gaussian) density over (cid:15)u and (cid:15)v . Further, we use logistic regression to model
the probability of a 2-d position (u + (cid:15)u ; v + (cid:15)v ) in ^C being a good grasping point:
(3)
P ( ^z (u + (cid:15)u ; v + (cid:15)v ) = 1j ^C ) = P ( ^z (u + (cid:15)u ; v + (cid:15)v ) = 1jx; w) = 1=(1 + e(cid:0)wT x )
where x 2 R459 are the features for the rectangular patch centered at (u + (cid:15)u ; v + (cid:15)v ) in image
^C (described in Section 2.1). The parameter of this model w 2 R459 is learned using standard
maximum likelihood for logistic regression: w = arg maxw0 Qi P (zi jxi ; w 0 ), where (xi ; zi ) are
the synthetic training examples (image patches and labels), as described in Section 2.2. Fig. 5 shows
the result of applying the learned logistic regression model to some real (non-synthetic) images.
Given two or more images of a new object from different camera positions, we want to infer the
3-d position of the grasping point. (See Fig. 4.) Because logistic regression may have predicted
multiple grasping points per image, there is usually ambiguity in the correspondence problem (i.e.,
which grasping point in one image corresponds to which graping point in another). To address this
while also taking into account the uncertainty in camera position, we propose a probabilistic model
over possible grasping points in 3-d space. In detail, we discretize the 3-d work-space of the robotic
arm into a regular 3-d grid G (cid:26) R3 , and associate with each grid element j a random variable
yj = 1fgrid cell j is a grasping pointg.
From each camera location i = 1; :::; N , one image is taken. In image Ci , let the ray passing through
(u; v) be denoted Ri (u; v). Let Gi (u; v) (cid:26) G be the set of grid-cells through which the ray Ri (u; v)
passes. Let r1 ; :::rK 2 Gi (u; v) be the indices of the grid-cells lying on the ray Ri (u; v) .
6The robot position/orientation error is typically small (position is usually accurate to within 1mm), but it
is still important to model this error. From our experiments (see Section 4), if we set (cid:27) 2 = 0, the triangulation
is highly inaccurate, with average error in predicting grasping point being 15:40 cm, as compared to 1:85 cm
when appropriate (cid:27) 2 is chosen.

Figure 4: (a) Diagram illustrating rays from two images C1 and C2 intersecting at a grasping point
(shown in dark blue). (b) Actual plot in 3-d showing multiple rays from 4 images intersecting at
the grasping point. All grid-cells with at least one ray passing nearby are colored using a light
blue-green-dark blue colormap, where dark blue represents those grid-cells which have many rays
passing near them. (Best viewed in color.)

We know that if any of the grid-cells rj along the ray represent a grasping point, then its projection
is a grasp point. More formally, zi (u; v) = 1 if and only if yr1 = 1 or yr2 = 1 or . . . or yrK = 1.
For simplicity, we use a (arguably unrealistic) naive Bayes-like assumption of independence, and
model the relation between P (zi (u; v) = 1jCi ) and P (yr1 = 1 or : : : or yrK = 1jCi ) as

(4)
P (zi (u; v) = 0jCi ) = P (yr1 = 0; :::; yrK = 0jCi ) = QK
j=1 P (yrj = 0jCi )
Assuming that any grid-cell along a ray is equally likely to be a grasping point, this therefore gives
(5)
P (yrj = 1jCi ) = 1 (cid:0) (1 (cid:0) P (zi (u; v) = 1jCi ))1=K
Next, using another naive Bayes-like independence assumption, we estimate the probability of a
particular grid-cell yj 2 G being a grasping point as:

P (yj = 1jC1 ; :::; CN ) = P (yj =1)P (C1 ;:::;CN jyj =1)
= P (yj =1)
P (C1 ;:::;CN ) QN
i=1 P (Ci jyj = 1)
P (C1 ;:::;CN )
P (yj =1jCi )P (Ci )
= P (yj =1)
P (C1 ;:::;CN ) QN
/ QN
i=1 P (yj = 1jCi )
i=1
P (yj =1)
where P (yj = 1) is the prior probability of a grid-cell being a grasping point (set to a constant
value in our experiments). Using Equations 2, 3, 5, and 7, we can now compute (up to a constant
of proportionality that does not depend on the grid-cell) the probability of any grid-cell y j being a
valid grasping point, given the images.
2.4 MAP Inference
We infer the best grasping point by choosing the 3-d position (grid-cell) that is most likely to be a
valid grasping point. More formally, using Eq. 5 and 7, we will choose:

(6)
(7)

arg maxj log P (yj = 1jC1 ; :::; CN ) = arg maxj log QN
i=1 P (yj = 1jCi )
= arg maxj PN
i=1 log (cid:0)1 (cid:0) (1 (cid:0) P (zi (u; v) = 1jCi ))1=K (cid:1)

(8)
(9)

where P (zi (u; v) = 1jCi ) is given by Eq. 2 and 3. A straightforward implementation that explic-
itly computes the sum above for every single grid-cell would give good grasping performance, but
be extremely inef(cid:2)cient (over 110 seconds). For real-time manipulation, we therefore used a more
ef(cid:2)cient search algorithm in which we explicitly consider only grid-cells yj that at least one ray
Ri (u; v) intersects. Further, the counting operation in Eq. 9 is implemented using an ef(cid:2)cient count-
ing algorithm that accumulates the sums over all grid-cells by iterating over all the images N and
rays Ri (u; v).7 This results in an algorithm that identi(cid:2)es a grasping position in 1.2 sec.
7 Since there are only a few places in an image where P (zi (u; v) = 1jCi ) > 0, the counting algorithm is
computationally much less expensive than enumerating over all grid-cells. In practice, we found that restricting
attention to areas where P (zi (u; v) = 1jCi ) > 0:1 allows us to further reduce the number of rays to be
considered, with no noticeable degradation in performance.

Figure 5: Grasping point classi(cid:2)cation. The red points in each image show the most likely locations,
predicted to be candidate grasping points by our logistic regression model. (Best viewed in color.)

Figure 6: The robotic arm picking up various objects: box, screwdriver, duct-tape, wine glass, a
solder tool holder, powerhorn, cellphone, and martini glass and cereal bowl from dishwasher.
3 Control
Having identi(cid:2)ed a grasping point, we have to move the end-effector of the robotic arm to it, and
pick up the object. In detail, our algorithm plans a trajectory in joint angle space [5] to take the end-
effector to an approach position,8 and then moves the end-effecter in a straight line forward towards
the grasping point. Our robotic arm uses two classes of grasps: downward grasps and outward
grasps. These arise as a direct consequence of the shape of the workspace of our 5 dof robotic arm
(Fig. 6). A (cid:147)downward(cid:148) grasp is used for objects that are close to the base of the arm, which the
arm will grasp by reaching in a downward direction. An (cid:147)outward(cid:148) grasp is for objects further away
from the base, for which the arm is unable to reach in a downward direction. The class is determined
based on the position of the object and grasping point.
4 Experiments
4.1 Hardware Setup
Our experiments used a mobile robotic platform called STAIR (STanford AI Robot) on which are
mounted a robotic arm, as well as other equipment such as our web-camera, microphones, etc.
STAIR was built as part of a project whose long-term goal is to create a robot that can navigate home
and of(cid:2)ce environments, pick up and interact with objects and tools, and intelligently converse with
and help people in these environments. Our algorithms for grasping novel objects represent a (cid:2)rst
step towards achieving some of these goals. The robotic arm we used is the Harmonic Arm made
by Neuronics. This is a 4 kg, 5-dof arm equipped with a parallel plate gripper, and has a positioning
accuracy of (cid:6)1 mm. Our vision system used a low-quality webcam mounted near the end-effector.
8The approach position is set to be a (cid:2)xed distance away from the predicted grasp point.

Table 1: Average absolute error in locating the grasp point for different objects, as well as grasp
success rate for picking up the different objects using our robotic arm. (Although training was done
on synthetic images, testing was done on the real robotic arm and real objects.)
NOV E L OB J EC T S
OB J EC T S S IM I LAR TO ON E S TRA IN ED ON
T E S T ED ON
M EAN
GRA S P -
M EAN
ERROR (CM )
ERROR (CM )
RAT E
1 . 8
1 . 0
1 . 1
1 . 1
1 . 7
3 . 1
3 . 6
1 . 4
1 . 8 5

DUC T TA P E
K EY S
MARK ER S /SCR EWDR IV ER
TOOTHBRU SH /CU T T ER
JUG
TRAN S LUC EN T BOX
POW ERHORN
CO I L ED W IR E
OV ERA L L

GRA S P -
RAT E
1 0 0%
1 0 0%
1 0 0%
1 0 0%
7 5%
7 5%
5 0%
1 0 0%
8 7 . 5%

MUG S
P EN S
W IN E G LA S S
BOOK S
ERA S ER /
C E L L PHON E

2 . 4
0 . 9
1 . 2
2 . 9

1 . 6

7 5%
1 0 0%
1 0 0%
7 5%

1 0 0%

9 0%

T E S T ED ON

OV ERA L L

1 . 8 0

4.2 Results and Discussion
We (cid:2)rst evaluated the predictive accuracy of the algorithm on synthetic images (not contained in
the training set). (See Fig. 5.) The average accuracy for classifying whether a 2-d image patch is a
projection of a grasping point was 94.2% (evaluated on a balanced test set), although the accuracy
in predicting 3-d grasping points was higher because the probabilistic model for inferring a 3-d
grasping point automatically aggregates data from multiple images, and therefore (cid:147)(cid:2)xes(cid:148) some of
the errors from individual classi(cid:2)ers.
We then tested the algorithm on the physical robotic arm. Here, the task was to use input from a
web-camera, mounted on the robot, to pick up an object placed in front of the robot. Recall that the
parameters of the vision algorithm were trained from synthetic images of a small set of six object
classes, namely books, martini glasses, white-board erasers, coffee mugs, tea cups and pencils. We
performed experiments on coffee mugs, wine glasses (partially (cid:2)lled with water), pencils, books,
and erasers(cid:151)but all of different dimensions and appearance than the ones in the training set(cid:151)
as well as a large set of objects from novel object classes, such as rolls of duct tape, markers, a
translucent box, jugs, knife-cutters, cellphones, pens, keys, screwdrivers, staplers, toothbrushes,
a thick coil of wire, a strangely shaped power horn, etc. (See Fig. 1.) We note that many of these
objects are translucent, textureless, and/or re(cid:3)ective, making 3-d reconstruction dif(cid:2)cult for standard
stereo systems. (Indeed, a carefully-calibrated Point Gray stereo system, the Bumblebee BB-COL-
20, (cid:151)with higher quality cameras than our web-camera(cid:151)fails to accurately reconstruct the visible
portions of 9 out of 12 objects.)
In extensive experiments, the algorithm for predicting grasps in images appeared to generalize very
well. Despite being tested on images of real (rather than synthetic) objects, including many very
different from ones in the training set, it was usually able to identify correct grasp points. We note
that test set error (in terms of average absolute error in the predicted position of the grasp point) on
the real images was only somewhat higher than the error on synthetic images; this shows that the
algorithm trained on synthetic images transfers well to real images. (Over all 5 object types used
in the synthetic data, average absolute error was 0.81cm in the synthetic images; and over all the
13 real test objects, average error was 1.83cm.) For comparison, neonate humans can grasp simple
objects with an average accuracy of 1.5cm. [2]
Table 1 shows the errors in the predicted grasping points on the test set. The table presents results
separately for objects which were similar to those we trained on (e.g., coffee mugs) and those which
were very dissimilar to the training objects (e.g., duct tape). In addition to reporting errors in grasp
positions, we also report the grasp success rate, i.e., the fraction of times the robotic arm was able
to physically pick up the object (out of 4 trials). On average, the robot picked up the novel objects
87.5% of the time.
For simple objects such as cellphones, wine glasses, keys, toothbrushes, etc., the algorithm per-
formed perfectly (100% grasp success rate). However, grasping objects such as mugs or jugs (by
the handle) allows only a narrow trajectory of approach(cid:151)where one (cid:147)(cid:2)nger(cid:148) is inserted into the
handle(cid:151)so that even a small error in the grasping point identi(cid:2)cation causes the arm to hit and
move the object, resulting in a failed grasp attempt. Although it may be possible to improve the

algorithm’s accuracy, we believe that these problems can best be solved by using a more advanced
robotic arm that is capable of haptic (touch) feedback.
In many instances, the algorithm was able to pick up completely novel objects (a strangely shaped
power-horn, duct-tape, solder tool holder, etc.; see Fig. 1 and 6). Perceiving a transparent wine glass
is a dif(cid:2)cult problem for standard vision (e.g., stereopsis) algorithms because of re(cid:3)ections, etc.
However, as shown in Table 1, our algorithm successfully picked it up 100% of the time. The same
rate of success holds even if the glass is 2/3 (cid:2)lled with water. Videos showing the robot grasping
the objects, are available at
http://ai.stanford.edu/(cid:24)asaxena/learninggrasp/
We also applied our learning algorithm to the task of unloading items from a dishwasher.9 Fig. 5
demonstrates that the algorithm correctly identi(cid:2)es the grasp on multiple objects even in the presence
of clutter and occlusion. Fig. 6 shows our robot unloading some items from a dishwasher.
5 Conclusions
We proposed an algorithm to enable a robot to grasp an object that it has never seen before. Our
learning algorithm neither tries to build, nor requires, a 3-d model of the object. Instead it predicts,
directly as a function of the images, a point at which to grasp the object.
In our experiments,
the algorithm generalizes very well to novel objects and environments, and our robot successfully
grasped a wide variety of objects, such as wine glasses, duct tape, markers, a translucent box, jugs,
knife-cutters, cellphones, keys, screwdrivers, staplers, toothbrushes, a thick coil of wire, a strangely
shaped power horn, and others, none of which were seen in the training set.
Acknowledgment
We give warm thanks to Anya Petrovskaya, Morgan Quigley, and Jimmy Zhang for help with the robotic arm
control driver software. This work was supported by the DARPA transfer learning program under contract
number FA8750-05-2-0249.

References
[1] A. Bicchi and V. Kumar. Robotic grasping and contact: a review. In ICRA, 2000.
[2] T. G. R. Bower, J. M. Broughton, and M. K. Moore. Demonstration of intention in the reaching behaviour
of neonate humans. Nature, 228:679(cid:150)681, 1970.
[3] A. S. Glassner. An Introduction to Ray Tracing. Morgan Kaufmann Publishers, Inc., San Francisco, 1989.
In IEEE/RJS International
[4] K. Hsiao and T. Lozano-Perez.
Imitation learning of whole-body grasps.
Conference on Intelligent Robots and Systems (IROS), 2006.
[5] M. T. Mason and J. K. Salisbury. Manipulator grasping and pushing operations. In Robot Hands and the
Mechanics of Manipulation. The MIT Press, Cambridge, MA, 1985.
[6] J. Michels, A. Saxena, and A. Y. Ng. High speed obstacle avoidance using monocular vision and rein-
forcement learning. In ICML, 2005.
[7] Miller and et. al. Automatic grasp planning using shape primitives. In ICRA, 2003.
[8] R. Pelossof and et. al. An svm learning approach to robotic grasping. In ICRA, 2004.
[9] J. H. Piater. Learning visual features to predict hand orientations. In ICML Workshop on Machine Learn-
ing of Spatial Knowledge, 2002.
[10] R. Platt, A. H. Fagg, and R. Grupen. Reusing schematic grasping policies. In IEEE-RAS International
Conference on Humanoid Robots, Tsukuba, Japan, 2005.
[11] A. Saxena, S. H. Chung, and A. Y. Ng. Learning depth from single monocular images. In NIPS 18, 2005.
[12] A. Saxena, J. Driemeyer, J. Kearns, C. Osondu, and A. Y. Ng. Learning to grasp novel objects using
vision. In 10th International Symposium of Experimental Robotics (ISER), 2006.
[13] A. Saxena, J. Schulte, and A. Y. Ng. Depth estimation using monocular and stereo cues. In 20th Interna-
tional Joint Conference on Arti(cid:2)cial Intelligence (IJCAI), 2007.
[14] H. Schneiderman and T. Kanade. Probabilistic modeling of local appearance and spatial relationships for
object recognition. In CVPR, 1998.
[15] T. Shin-ichi and M. Satoshi. Living and working with robots. Nipponia, 2000.

9To improve performance, we also used depth-based features. More formally, we applied our texture based
features to the depth image obtained from a stereo camera, and appended them to the feature vector used in
classi(cid:2)cation. We also appended some hand-labeled real examples of dishwasher images to the training set to
prevent the algorithm from identifying grasping points on background clutter, such as dishwasher prongs.

