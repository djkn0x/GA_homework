Selecting the State-Representation
in Reinforcement Learning

Odalric-Ambrym Maillard
INRIA Lille - Nord Europe
odalricambrym.maillard@gmail.com

R ´emi Munos
INRIA Lille - Nord Europe
remi.munos@inria.fr

Daniil Ryabko
INRIA Lille - Nord Europe
daniil@ryabko.net

Abstract

The problem of selecting the right state-representation in a reinforcement learning
problem is considered. Several models (functions mapping past observations to
a ﬁnite set) of the observations are given, and it is known that for at least one of
these models the resulting state dynamics are indeed Markovian. Without know-
ing neither which of the models is the correct one, nor what are the probabilistic
characteristics of the resulting MDP, it is required to obtain as much reward as the
optimal policy for the correct model (or for the best of the correct models, if there
are several). We propose an algorithm that achieves that, with a regret of order
T 2/3 where T is the horizon time.

1

Introduction

We consider the problem of selecting the right state-representation in an average-reward reinforce-
ment learning problem. Each state-representation is deﬁned by a model φj (to which corresponds a
state space Sφj ) and we assume that the number J of available models is ﬁnite and that (at least) one
model is a weakly-communicating Markov decision process (MDP). We do not make any assump-
tion at all about the other models. This problem is considered in the general reinforcement learning
setting, where an agent interacts with an unknown environment in a single stream of repeated ob-
servations, actions and rewards. There are no “resets,” thus all the learning has to be done online.
Our goal is to construct an algorithm that performs almost as well as the algorithm that knows both
which model is a MDP (knows the “true” model) and the characteristics of this MDP (the transition
probabilities and rewards).
Consider some examples that help motivate the problem. The ﬁrst example is high-level feature
selection. Suppose that the space of histories is huge, such as the space of video streams or that of
game plays. In addition to these data, we also have some high-level features extracted from it, such
as “there is a person present in the video” or “the adversary (in a game) is aggressive.” We know that
most of the features are redundant, but we also know that some combination of some of the features
describes the problem well and exhibits Markovian dynamics. Given a potentially large number
of feature combinations of this kind, we want to ﬁnd a policy whose average reward is as good as
that of the best policy for the right combination of features. Another example is bounding the order
of an MDP. The process is known to be k-order Markov, where k is unknown but un upper bound
K >> k is given. The goal is to perform as well as if we knew k . Yet another example is selecting
the right discretization. The environment is an MDP with a continuous state space. We have several
candidate quantizations of the state space, one of which gives an MDP. Again, we would like to ﬁnd
a policy that is as good as the optimal policy for the right discretization. This example also opens

1

the way for extensions of the proposed approach: we would like to be able to treat an inﬁnite set
of possible discretization, none of which may be perfectly Markovian. The present work can be
considered the ﬁrst step in this direction.
It is important to note that we do not make any assumptions on the “wrong” models (those that do
not have Markovian dynamics). Therefore, we are not able to test which model is Markovian in the
classical statistical sense, since in order to do that we would need a viable alternative hypothesis
(such as, the model is not Markov but is K -order Markov). In fact, the constructed algorithm never
“knows” which model is the right one; it is “only” able to get the same average level of reward as if
it knew.
Previous work. This work builds on previous work on learning average-reward MDPs. Namely,
we use in our algorithm as a subroutine the algorithm UCRL2 of [6] that is designed to provide
ﬁnite time bounds for undiscounted MDPs. Such a problem has been pioneered in the reinforcement
learning literature by [7] and then improved in various ways by [4, 11, 12, 6, 3]; UCRL2 achieves a
regret of the order DT 1/2 in any weakly-communicating MDP with diameter D , with respect to the
best policy for this MDP. The diameter D of a MDP is deﬁned in [6] as the expected minimum time
required to reach any state starting from any other state. A related result is reported in [3], which
improves on constants related to the characteristics of the MDP.
A similar approach has been considered in [10]; the difference is that in that work the probabilistic
characteristics of each model are completely known, but the models are not assumed to be Marko-
vian, and belong to a countably inﬁnite (rather than ﬁnite) set.
The problem we address can be also viewed as a generalization of the bandit problem (see e.g. [9,
8, 1]): there are ﬁnitely many “arms”, corresponding to the policies used in each model, and one
of the arms is the best, in the sense that the corresponding model is the “true” one. In the usual
bandit setting, the rewards are assumed to be i.i.d. thus one can estimate the mean value of the arms
while switching arbitrarily from one arm to the next (the quality of the estimate only depends on the
number of pulls of each arm). However, in our setting, estimating the average-reward of a policy
requires playing it many times consecutively. This can be seen as a bandit problem with dependent
arms, with complex costs of switching between arms.
Contribution. We show that despite the fact that the true Markov model of states is unknown
and that nothing is assumed on the wrong representations, it is still possible to derive a ﬁnite-time
analysis of the regret for this problem. This is stated in Theorem 1; the bound on the regret that we
obtain is of order T 2/3 .
The intuition is that if the “true” model φ∗ is known, but its probabilistic properties are not, then we
still know that there exists an optimal control policy that depends on the observed state sj ∗ ,t only.
Therefore, the optimal rate of rewards can be obtained by a clever exploration/exploitation strategy,
such as UCRL2 algorithm [6]. Since we do not know in advance which model is a MDP, we need
to explore them all, for a sufﬁciently long time in order to estimate the rate of rewards that one can
get using a good policy in that model.
Outline. In Section 2 we introduce the precise notion of model and set up the notations. Then we
present the proposed algorithm in Section 3; it uses UCRL2 of [6] as a subroutine and selects the
models φ according to a penalized empirical criterion. In Section 4 we discuss some directions for
further development. Finally, Section 5 is devoted to the proof of Theorem 1.

2 Notation and deﬁnitions
We consider a space of observations O , a space of actions A, and a space of rewards R (all assumed
to be Polish). Moreover, we assume that A is of ﬁnite cardinality A def= |A| and that 0 ∈ R ⊂ [0, 1].
∞(cid:91)
The set of histories up to time t for all t ∈ N ∪ {0} will be denoted by H<t
def= O × (A × R × O)t−1 ,
and we deﬁne the set of all possible histories by H def=
H<t .
Environments. For a Polish X , we Denote by P (X ) the set of probability distributions over X .
t=1
Deﬁne an environment to be a mapping from the set of histories H to the set of functions that map
any action a ∈ A to a probability distribution νa ∈ P (R × O) over the product space of rewards
and observations.

2

We consider the problem of reinforcement learning when the learner interacts with some unknown
environment e(cid:63) . The interaction is sequential and goes as follows: ﬁrst some h<1 = {o0} is gen-
erated according to ι, then at time step t > 0, the learner choses an action at ∈ A according to the
current history h<t ∈ H<t . Then a couple of reward and observations (rt , ot ) is drawn according
to the distribution (e(cid:63) (h<t ))at ∈ P (R × O). Finally, h<t+1 is deﬁned by the concatenation of h<t
with (at , rt , ot ). With these notations, at each time step t > 0, ot−1 is the last observation given
to the learner before choosing an action, at is the action output at this step, and rt is the immediate
reward received after playing at .
State representation functions (models). Let S ⊂ N be some ﬁnite set; intuitively, this has to be
considered as a set of states. A state representation function φ is a function from the set of histories
H to S . For a state representation function φ, we will use the notation Sφ for its set of states, and
st,φ := φ(h<t ).
In the sequel, when we talk about a Markov decision process, it will be assumed to be weakly
communicating, which means that for each pair of states u1 , u2 there exists k ∈ N and a sequence
of actions α1 , .., αk ∈ A such that P (sk+1,φ = u2 |s1,φ = u1 , a1 = α1 ...ak = αk ) > 0. Having
that in mind, we introduce the following deﬁnition.

Deﬁnition 1 We say that an environment e with a state representation function φ is Markov, or, for
short, that φ is a Markov model (of e), if the process (st,φ , at , rt ), t ∈ N is a (weakly communicating)
Markov decision process.

For example, consider a state-representation function φ that depends only on the last observation,
and that partitions the observation space into ﬁnitely many cells. Then an environment is Markov
with this representation function if the probability distribution on the next cells only depends on the
last observed cell and action. Note that there may be many state-representation functions with which
an environment e is Markov.
3 Main results
Given a set Φ = {φj ; j (cid:54) J } of J state-representation functions (models), one of which being
a Markov model of the unknown environment e(cid:63) , we want to construct a strategy that performs
nearly as well as the best algorithm that knows which φj is Markov, and knows all the probabilistic
characteristics (transition probabilities and rewards) of the MDP corresponding to this model. For
∆(T ) def= T ρ(cid:63) − T(cid:88)
that purpose we deﬁne the regret of any strategy at time T , like in [6, 3], as
E((cid:80)T
t=1
where rt are the rewards received when following the proposed strategy and ρ(cid:63) is the average optimal
value in the best Markov model, i.e., ρ(cid:63) = limT
t=1 rt (π(cid:63) )) where rt (π(cid:63) ) are the rewards
1
T
received when following the optimal policy for the best Markov model. Note that this deﬁnition
makes sense since when the MDP is weakly communicating, the average optimal value of reward
does not depend on the initial state. Also, one could replace T ρ∗ with the expected sum of rewards
√
obtained in T steps (following the optimal policy) at the price of an additional O(
T ) term.

rt ,

In the next subsection, we describe an algorithm that achieves a sub-linear regret of order T 2/3 .

3.1 Best Lower Bound (BLB) algorithm
In this section, we introduce the Best-Lower-Bound (BLB) algorithm, described in Figure 1.
The algorithm works in stages of doubling length. Each stage consists in 2 phases: an exploration
and an exploitation phase.
In the exploration phase, BLB plays the UCRL2 algorithm on each
model (φj )1(cid:54)j(cid:54)J successively, as if each model φj was a Markov model, for a ﬁxed number τi,1,J
of rounds. The exploitation part consists in selecting ﬁrst the model with highest lower bound,
according to the empirical rewards obtained in the previous exploration phase. This model is initially
selected for the same time as in the exploration phase, and then a test decides to either continue
playing this model (if its performance during exploitation is still above the corresponding lower
bound, i.e. if the rewards obtained are still at least as good as if it was playing the best model). If it
does not pass the test, then another model (with second best lower-bound) is select and played, and
so on. Until the exploitation phase (of ﬁxed length τi,2 ) ﬁnishes and the next stage starts.

3

Parameters: f , δ
For each stage i (cid:62) 1 do
Set the total length of stage i to be τi := 2i .
. For each j ∈ {1, . . . , J } do
1. Exploration. Set τi,1 = τ 2/3
i
– Run UCRL2 with parameter δi (δ) deﬁned in (1) using φj during τi,1,J
the state space is assumed to be Sφj with transition structure
steps:
– Compute the corresponding average empirical reward (cid:98)µi,1 (φj ) received
induced by φj .
during this exploration phase.
2. Exploitation. Set τi,2 = τi − τi,1 and initialize J := {1, . . . , J } .
– Select (cid:98)j = argmax
(cid:98)µi,1 (φj ) − 2B (i, φj , δ) (using (3)).
While the current length of the exploitation part is less than τi,2 do
j∈J
– Run UCRL2 with parameter δi (δ) using φ(cid:98)j : update at each time step t
the current average empirical reward (cid:98)µi,2,t (φ(cid:98)j ) from the beginning of
the run. Provided that the length of the current run is larger than τi,1,J ,
(cid:98)µi,2,t (φ(cid:98)j ) (cid:62) (cid:98)µi,1 (φ(cid:98)j ) − 2B (i, φ(cid:98)j , δ) .
do the test
– If the test fails, then stop UCRL2 and set J := J \ {(cid:98)j }. If J = ∅
then set J := {1, . . . , J }.

Figure 1: The Best-Lower-Bound selection strategy.

def= 2i . Thus for a total time horizon T , the number
The length of stage i is ﬁxed and deﬁned to be τi
of stages I (T ) before time T is I (T ) def= (cid:120)log2 (T + 1)(cid:121). Each stage i (of length τi ) is further
decomposed into an exploration (length τi,1 ) and an exploitation (length τi,2 ) phases.
Exploration phase. All the models {φj }j(cid:54)J are played one after another for the same amount of
J . Each episode 1 (cid:54) j (cid:54) J consists in running the UCRL2 algorithm using the
def= τi,1
time τi,1,J
model of states and transitions induced by the state-representation function φj . Note that UCRL2
does not require the horizon T in advance, but requires a parameter p in order to ensure a near
optimal regret bound with probability higher than 1 − p. We deﬁne this parameter p to be δi (δ) in
stage i, where
The average empirical reward received during each episode is written (cid:98)µi,1 (φj ).
δi (δ) def= (2i − (J −1 + 1)22i/3 + 4)−1 2−i+1 δ .
(1)
Exploitation phase. We use the empirical rewards (cid:98)µi,1 (φj ) received in the previous exploration
part of stage i together with a conﬁdence bound in order to select the model to play. Moreover, a
model φ is no longer run for a ﬁxed period of time (as in the exploration part of stage i), but for a
period τi,2 (φ) that depends on some test; we ﬁrst initialize J := {1, . . . , J } and then choose
(cid:98)j def= argmax
(cid:98)µi,1 (φj ) − 2B (i, φj , δ) ,
(cid:115)
j∈J
A log( τi,1,J
δi (δ) )
B (i, φ, δ) def= 34f (τi − 1 + τi,1 )|Sφ |
(3)
,
τi,1,J
where δ and the function f are parameters of the BLB algorithm. Then UCRL2 is played using the
selected model φ(cid:98)j for the parameter δi (δ). In parallel we test whether the average empirical reward
we receive during this exploitation phase is high enough; at time t, if the length of the current episode
is larger than τ1,i,J , we test if(cid:98)µi,2,t (φ(cid:98)j ) (cid:62) (cid:98)µi,1 (φ(cid:98)j ) − 2B (i, φ(cid:98)j , δ).
(4)
model (cid:98)j is discarded (until the end of stage i) i.e. we update J := J \ {(cid:98)j } and we select a new one
If the test is positive, we keep playing UCRL2 using the same model. Now, if the test fails, then the
according to (2). We repeat those steps until the total time τi,2 of the exploitation phase of stage i is
over.

where we deﬁne

(2)

4

Remark Note that the model selected for exploitation in (2) is the one that has the best lower bound.
This is a pessimistic (or robust) selection strategy. We know that if the right model is selected, then
with high probability, this model will be kept during the whole exploitation phase. If this is not the
right model, then either the policy provides good rewards and we should keep playing it, or it does
not, in which case it will not pass the test (4) and will be removed from the set of models that will
be exploited in this phase.
3.2 Regret analysis
Theorem 1 (Main result) Assume that a ﬁnite set of J state-representation functions Φ is given,
and there exists at least one function φ(cid:63) ∈ Φ such that with φ(cid:63) as a state-representation function the
environment is a Markov decision process. If there are several such models, let φ(cid:63) be the one with
the highest average reward of the optimal policy of the corresponding MDP. Then the regret (with
respect to the optimal policy corresponding to φ∗ ) of the BLB algorithm run with parameter δ , for
(cid:17)1/2
(cid:16)
(cid:16)
(cid:17)1/2
any horizon T , with probability higher than 1 − δ is bounded as follows
−1 (cid:1) log2 (T )
AJ log (cid:0)(J δ)
−1 ) log2 (T )T
(cid:48)
∆(T ) (cid:54) cf (T )S
T 2/3 + c
+ c(f , D), (5)
A log(δ
DS
for some numerical constants c, c(cid:48) and c(f , D). The parameter f (t) can be chosen to be any
increasing function, for instance the choice f (t) := log2 t + 1, gives c(f , D) (cid:54) 2D .
The proof of this result is reported in Section 5.
Remark. Importantly, the algorithm considered here does not know in advance the diameter D of
the true model, nor the time horizon T . Due to this lack of knowledge, it uses a guess f (t) (e.g.
log(t)) on this diameter, which result in the additional regret term c(f , D) and the additional factor
f (T ); knowing D would enable to remove both of them, but this is a strong assumption. Choosing
f (t) := log2 t + 1 gives a bound which is of order T 2/3 in T but is exponential in D ; taking
f (t) := tε we get a bound of order T 2/3+ε in T but of polynomial order 1/ε in D .
4 Discussion and outlook
Intuition. The main idea why this algorithm works is as follows. The “wrong” models are used
during exploitation stages only as long as they are giving rewards that are higher than the rewards
that could be obtained in the “true” model. All the models are explored sufﬁciently long so as
to be able to estimate the optimal reward level in the true model, and to learn its policy. Thus,
nothing has to be known about the “wrong” models. This is in stark contrast to the usual situation
in mathematical statistics, where to be able to test a hypothesis about a model (e.g., that the data is
generated by a certain model versus some alternative models), one has to make assumptions about
alternative models. This has to be done in order to make sure that the Type II error is small (the
power of the test is large): that this error is small has to be proven under the alternative. Here,
although we are solving seemingly the same problem, the role of the Type II error is played by the
rewards. As long as the rewards are high we do not care where the model we are using is correct or
not. We only have to ensure that the true model passes the test.
Assumptions. A crucial assumption made in this work is that the “true” model φ∗ belongs to a
known ﬁnite set. While passing from a ﬁnite to a countably inﬁnite set appears rather straightfor-
ward, getting rid of the assumption that this set contains the true model seems more difﬁcult. What
one would want to obtain in this setting is sub-linear regret with respect to the performance of the
optimal policy in the best model; this, however, seems difﬁcult without additional assumptions on
the probabilistic characteristics of the models. Another approach not discussed here would be to try
to build a good state representation function, as what is suggested for instance in [5]. Yet another
interesting generalization in this direction would be to consider uncountable (possibly parametric
but general) sets of models. This, however, would necessarily require some heavy assumptions on
the set of models.
Regret. The reader familiar with adversarial bandit literature will notice that our bound of order
T 2/3 is worse than T 1/2 that usually appears in this context (see, for example [2]). The reason is
that our notion of regret is different: in adversarial bandit literature, the regret is measured with
respect to the best choice of the arm for the given ﬁxed history. In contrast, we measure the regret
with respect to the best policy (for knows the correct model and its parameters) that, in general,
would obtain completely different (from what our algorithm would get) rewards and observations
right from the beginning.

5

Estimating the diameter? As previously mentioned, a possibly large additive constant c(f , D)
appears in the regret since we do not known a bound on the diameter of the MDP in the “true”
model, and use log T instead. Finding a way to properly address this problem by estimating online
the diameter of the MDP is an interesting open question. Let us provide some intuition concerning
value function sp( (cid:98)V + ) is always smaller than the diameter D . This span increases as we get more
this problem. First, we notice that, as reported in [6], when we compute an optimistic model based
on the empirical rewards and transitions of the true model, the span of the corresponding optimistic
seems quite difﬁcult to compute a tight empirical upper bound on D (or sp( (cid:98)V + )). In [3], the authors
rewards and transitions samples, which gives a natural empirical lower bound on D . However, it
that sp( (cid:98)V + ) (cid:54) sp(V (cid:63) ), we need to introduce an explicit penalization in order to control the span of
derive a regret bound that scales with the span of the true value function sp(V (cid:63) ), which is also less
than D , and can be signiﬁcantly smaller in some cases. However, since we do not have the property
the computed optimistic models, and this requires assuming we know an upper bound B on sp(V (cid:63) )
in order to guarantee a ﬁnal regret bound scaling with B . Unfortunately this does not solve the
estimation problem of D , which remains an open question.
5 Proof of Theorem 1
In this section, we now detail the proof of Theorem 1. The proof is stated in several parts. First we
remind a general conﬁdence bound for the UCRL2 algorithm in the true model. Then we decompose
the regret into the sum of the regret in each stage i. After analyzing the contribution to the regret in
stage i, we then gather all stages and tune the length of each stage and episode in order to get the
ﬁnal regret bound.
5.1 Upper and Lower conﬁdence bounds
From the analysis of UCRL2 in [6], we have the property that with probability higher than 1 − δ (cid:48) ,
(cid:114)
t1+τ −1(cid:88)
the regret of UCRL2 when run for τ consecutive many steps from time t1 in the true model φ(cid:63) is
upper bounded by
A log( τ
ρ(cid:63) − 1
rt (cid:54) 34D |Sφ(cid:63) |
δ (cid:48) )
τ
τ
t=t1
where D is the diameter of the MDP. What is interesting is that this diameter does not need to be
(cid:114)
known by the algorithm. Also by carefully looking at the proof of UCRL, it can be shown that the
t1+τ −1(cid:88)
following bound is also valid with probability higher than 1 − δ (cid:48) :
A log( τ
rt − ρ(cid:63) (cid:54) 34D |Sφ(cid:63) |
δ (cid:48) )
1
.
(cid:114)
τ
τ
t=t1
We now deﬁne the following quantity, for every model φ, episode length τ and δ (cid:48) ∈ (0, 1)
A log( τ
BD (τ , φ, δ (cid:48) ) def= 34D |Sφ |
δ (cid:48) )
τ
5.2 Regret of stage i
In this section we analyze the regret of the stage i, which we denote ∆i . Note that since each stage
I (T )(cid:88)
i (cid:54) I is of length τi = 2i except the last one I that may stop before, we have
(8)
∆i ,
∆(T ) =
i=1
where I (T ) = (cid:120)log2 (T +1)(cid:121). We further decompose ∆i = ∆1,i+∆i,2 into the regret corresponding
to the exploration stage ∆1,i and the regret corresponding to the exploitation stage ∆i,2 .
τi,1 is the total length of the exploration stage i and τi,2 is the total length of the exploitation stage i.
def= τi,1
J the number of consecutive steps during which the UCRL2
For each model φ, we write τi,1,J
algorithm is run with model φ in the exploration stage i, and τi,2 (φ) the number of consecutive steps
during which the UCRL2 algorithm is run with model φ in the exploitation stage i.
Good and Bad models. Let us now introduce the two following sets of models, deﬁned after the
def= {φ ∈ Φ ; (cid:98)µi,1 (φ) − 2B (i, φ, δ) ≥ (cid:98)µi,1 (φ(cid:63) ) − 2B (i, φ(cid:63) , δ)}\{φ∗ } ,
end of the exploration stage, i.e. at time ti .
Gi
def= {φ ∈ Φ ; (cid:98)µi,1 (φ) − 2B (i, φ, δ) < (cid:98)µi,1 (φ(cid:63) ) − 2B (i, φ(cid:63) , δ)} .
Bi
With this deﬁnition, we have the decomposition Φ = Gi ∪ {φ(cid:63) } ∪ Bi .

(6)

,

.

(7)

6

5.2.1 Regret in the exploration phase
φ (cid:54)= φ(cid:63) is bounded by τi,1,J ρ(cid:63) . Now the regret for the true model is τi,1,J (ρ(cid:63) − (cid:98)µ1 (φ(cid:63) )), thus the
Since in the exploration stage i each model φ is run for τi,1,J many steps, the regret for each model
∆i,1 (cid:54) τi,1,J (ρ(cid:63) − (cid:98)µ1 (φ(cid:63) )) + (J − 1)τi,1,J ρ(cid:63) .
total contribution to the regret in the exploration stage i is upper-bounded by
(9)
5.2.2 Regret in the exploitation phase
By deﬁnition, all models in Gi ∪ {φ(cid:63) } are selected before any model in Bi is selected.
The good models. Let us consider some φ ∈ Gi and an event Ωi under which the exploitation
phase does not reset. The test (equation (4)) starts after τi,1,J , thus, since there is not reset, either
τi,2 (φ) = τi,1,J in which case the contribution to the regret is bounded by τi,1,J ρ(cid:63) , or τi,2 (φ) >
τi,1,J , in which case the regret during the (τi,2 (φ) − 1) steps (where the test was successful) is
(τi,2 (φ) − 1)(ρ(cid:63) − (cid:98)µi,2,τi,2 (φ)−1 (φ)) (cid:54) (τi,2 (φ) − 1)(ρ(cid:63) − (cid:98)µi,1 (φ) + 2B (i, φ, δ))
bounded by
(cid:54) (τi,2 (φ) − 1)(ρ(cid:63) − (cid:98)µi,1 (φ(cid:63) ) + 2B (i, φ(cid:63) , δ)) ,
and now since in the last step φ fails to pass the test, this adds a contribution to the regret at most ρ(cid:63) .
We deduce that the total contribution to the regret of all the models φ ∈ Gi in the exploitation stages
∆i,2 (Gi ) (cid:54) (cid:88)
max{τi,1,J ρ(cid:63) , (τi,2 (φ) − 1)(ρ(cid:63) − (cid:98)µi,1 (φ(cid:63) ) + 2B (i, φ(cid:63) , δ)) + ρ(cid:63) } .
on the event Ωi is bounded by
(10)
φ∈G
step i is given by τi,2 (φ(cid:63) )(ρ(cid:63) − (cid:98)µi,2,t (φ(cid:63) )) , then the total regret of the exploration and exploitation
The true model. First, let us note that since the total regret of the true model during the exploitation
∆i (cid:54) τi,1,J (ρ(cid:63) − (cid:98)µ1 (φ(cid:63) )) + τi,1,J (J − 1)ρ(cid:63) + τi,2 (φ(cid:63) )(ρ(cid:63) − (cid:98)µi,2,ti+τi,2 (φ(cid:63) )) +
stages in episode i on Ωi is bounded by
(cid:88)
(cid:88)
max{τi,1,J ρ(cid:63) , (τi,2 (φ) − 1)(ρ(cid:63) − (cid:98)µi,1 (φ(cid:63) ) + 2B (i, φ(cid:63) , δ)) + ρ(cid:63) } +
φ∈Gi
φ∈Bi
Now from the analysis provided in [6] we know that when we run the UCRL2 with the true model
φ(cid:63) with parameter δi (δ), then there exists an event Ω1,i of probability at least 1 − δi (δ) such that on
ρ(cid:63) − (cid:98)µi,1 (φ(cid:63) ) (cid:54) BD (τi,1,J , φ(cid:63) , δi (δ)) ,
this event
ρ(cid:63) − (cid:98)µi,2,t (φ(cid:63) ) (cid:54) BD (τi,2 (φ(cid:63) ), φ(cid:63) , δ1 (δ)) .
and similarly there exists an event Ω2,i of probability at least 1 − δi (δ), such that on this event
so that (cid:88)
Now we show that, with high probability, the true model φ(cid:63) passes all the tests (equation (4)) until
the end of the episode i, and thus equivalently, with high probability no model φ ∈ Bi is selected,
τi,2 (φ) = 0.
φ∈Bi
For the true model, after τ (φ(cid:63) , t) (cid:62) τi,1,J , there remains at most (τi,2 − τi,1,J + 1) possible timesteps
corresponding to (cid:98)µi,1 (φ(cid:63) ) is shared by all the tests. Thus we deduce that with probability higher
where we do the test for the true model φ(cid:63) . For each test we need to control µi,2,t (φ(cid:63) ), and the event
than 1 − (τi,2 − τi,1,J + 2)δi (δ) we have simultaneously on all time step until the end of exploitation
(cid:98)µi,2,t (φ(cid:63) ) − (cid:98)µi,1 (φ(cid:63) ) = (cid:98)µi,2,t (φ(cid:63) ) − ρ(cid:63) + ρ(cid:63) − (cid:98)µi,1 (φ(cid:63) )
phase of stage i,
(cid:62) −BD (τ (φ(cid:63) , t), φ(cid:63) , δi (δ)) − BD (τi,1,J , φ(cid:63) , δi (δ))
(cid:62) −2BD (τi,1,J , φ(cid:63) , δi (δ)) .
Now provided that f (ti ) (cid:62) D , then BD (τi,1,J , φ(cid:63) , δi (δ)) (cid:54) B (i, φ(cid:63) , δ) , thus the true model passes
event, we thus have (cid:88)
all tests until the end of the exploitation part of stage i on an event Ω3,i of probability higher than
1 − (τi,2 − τi,1,J + 2)δi (δ). Since there is no reset, we can choose Ωi
def= Ω3,i . Note that on this
τi,2 (φ) = 0.
φ∈Bi

τi,2 (φ)ρ(cid:63) .

7

By using a union bound over the events Ω1,i , Ω2,i and Ω3,i , then we deduce that with probability
higher than 1 − (τi,2 − τi,1,J + 4)δi (δ),
(cid:88)
∆i (cid:54) τi,1,J BD (τi,1,J , φ(cid:63) , δi (δ))) + [τi,1,J (J − 1) + |Gi |]ρ(cid:63) + τi,2 (φ(cid:63) )BD (τi,2 (φ(cid:63) ), φ(cid:63) , δi (δ))
max{(τi,1,J − 1)ρ(cid:63) , (τi,2 (φ) − 1)(BD (τi,1,J , φ(cid:63) , δi (δ)) + 2B (i, φ(cid:63) , δ)} .
+
φ∈Gi
Now using again the fact that f (ti ) (cid:62) D , and after some simpliﬁcations, we deduce that
(cid:88)
∆i (cid:54) τi,1,J BD (τi,1,J , φ(cid:63) , δi (δ)) + τi,2 (φ(cid:63) )BD (τi,2 (φ(cid:63) ), φ(cid:63) , δi (δ))
(τi,2 (φ) − 1)3B (i, φ(cid:63) , δ) + τi,1,J (J + |Gi | − 1)ρ(cid:63) .
+
φ∈Gi
Finally, we use the fact that τ BD (τ , φ(cid:63) , δi (δ)) is increasing with τ to deduce the following rough
bound that holds with probability higher than 1 − (τi,2 − τi,1,J + 4)δi (δ)
(cid:88)
∆i (cid:54) τi,2B (i, φ(cid:63) , δ) + τi,2BD (τi,2 , φ(cid:63) , δi (δ)) + 2J τi,1,J ρ(cid:63) ,
where we used the fact that τi,2 = τi,2 (φ(cid:63) ) +
τi,2 (φ) .
φ∈G

5.3 Tuning the parameters of each stage.
We now conclude by tuning the parameters of each stage, i.e. the probabilities δi (δ) and the length
τi , τi,1 and τi,2 . The total length of stage i is by deﬁnition

.

[34f (ti )S

2i +

2iρ(cid:63) .

AJ log

τi + 2τ 2/3
i

ρ(cid:63) ,

τi = τi,1 + τi,2 = τi,1,J J + τi,2 ,
def= τi − τ 2/3
and τi,1,J = τ 2/3
def= τ 2/3
where τi = 2i . So we set τi,1
and then we have τi,2
J . Now
i
i
i
(cid:115)
using these values and the deﬁnition of the bound B (i, φ(cid:63) , δ), and BD (τi,2 , φ(cid:63) , δi (δ)), we deduce
(cid:114)
with probability higher than 1 − (τi,2 − τi,1,J + 4)δi (δ) the following upper bound
(cid:16) τi
(cid:16) τ 2/3
(cid:17)
(cid:17)
(cid:17)1/2
(cid:16) J
∆i (cid:54) 34f (ti )S
τ 2/3
i
i + 34DS
A log
J δi (δ)
δi (δ)
τi,2 (cid:54) √
with ti = 2i − 1 + 22i/3 and where we used the fact that
J τ 2/3
i
τ 2/3
i
We now deﬁne δi (δ) such that δi (δ) def= (2i − (J −1 + 1)22i/3 + 4)−1 2−i+1 δ .
Since for the stages i ∈ I0
def= {i (cid:62) 1; f (ti ) < D}, the regret is bounded by ∆i (cid:54) τiρ(cid:63) , then the
total cumulative regret of the algorithm is bounded with probability higher than 1 − δ (using the
(cid:114)
(cid:114)
(cid:16) 28i/3
(cid:16) 23i
(cid:17)
(cid:17)
∆(T ) (cid:54) (cid:88)
(cid:88)
deﬁtion of the δi (δ)) by
J A log
A log
δ
J δ
i∈I0
i /∈I0
where ti = 2i − 1 + 22i/3 (cid:54) T .
We conclude by using the fact that since I (T ) (cid:54) log2 (T + 1), then with probability higher than
(cid:17)1/2
(cid:16)
(cid:16)
(cid:17)1/2
1 − δ , the following bound on the regret holds
for some constant c, c(cid:48) , and where c(f , D) = (cid:80)
A log(δ−1 ) log2 (T )T
T 2/3 + c(cid:48)DS
AJ log(J δ)−1 log2 (T )
∆(T ) (cid:54) cf (T )S
2iρ(cid:63) . Now for the special choice when f (T ) def=
i∈I0
log2 (T +1), then i ∈ I0 means 2i+22i/3 < 2D+2, thus we must have i < D , and thus c(f , d) (cid:54) 2D .
Acknowledgements
This research was partially supported by the French Ministry of Higher Education and Research,
Nord- Pas-de-Calais Regional Council and FEDER through CPER 2007-2013, ANR projects
EXPLO-RA (ANR-08-COSI-004) and Lampada (ANR-09-EMER-007), by the European Com-
munitys Seventh Framework Programme (FP7/2007-2013) under grant agreement 231495 (project
CompLACS), and by Pascal-2.

+ 2]22i/3 + 34DS

+ c(f , D) .

8

References
[1] Peter Auer, Nicol `o Cesa-Bianchi, and Paul Fischer. Finite time analysis of the multiarmed
bandit problem. Machine Learning, 47(2-3):235–256, 2002.
[2] Peter Auer, Nicol `o Cesa-Bianchi, Yoav Freund, and Robert E. Schapire. Gambling in a rigged
In Foundations of Computer Science,
casino: The adversarial multi-armed bandit problem.
1995. Proceedings., 36th Annual Symposium on, pages 322 –331, oct 1995.
[3] Peter L. Bartlett and Ambuj Tewari. REGAl: a regularization based algorithm for reinforce-
ment learning in weakly communicating mdps. In Proceedings of the Twenty-Fifth Conference
on Uncertainty in Artiﬁcial Intelligence, UAI, pages 35–42, Arlington, Virginia, United States,
2009. AUAI Press.
[4] Ronen I. Brafman and Moshe Tennenholtz. R-max - a general polynomial time algorithm
for near-optimal reinforcement learning. Journal of Machine Learning Research, 3:213–231,
March 2003.
[5] Marcus Hutter. Feature reinforcement learning: Part I: Unstructured MDPs. Journal of Artiﬁ-
cial General Intelligence, 1:3–24, 2009.
[6] Thomas Jaksch, Ronald Ortner, and Peter Auer. Near-optimal regret bounds for reinforcement
learning. Journal of Machine Learning Research, 99:1563–1600, August 2010.
[7] Michael Kearns and Satinder Singh. Near-optimal reinforcement learning in polynomial time.
Machine Learning, 49:209–232, November 2002.
[8] Tze L. Lai and Herbert Robbins. Asymptotically efﬁcient adaptive allocation rules. Advances
in Applied Mathematics, 6:4–22, 1985.
[9] Herbert Robbins. Some aspects of the sequential design of experiments. Bulletin of the Amer-
ican Mathematics Society, 58:527–535, 1952.
[10] Daniil Ryabko and Marcus Hutter. On the possibility of learning in reactive environments with
arbitrary dependence. Theoretical Compututer Science, 405:274–284, October 2008.
[11] Alexander L. Strehl, Lihong Li, Eric Wiewiora, John Langford, and Michael L. Littman. PAC
In Proceedings of the 23rd international conference on
model-free reinforcement learning.
Machine learning, ICML, pages 881–888, New York, NY, USA, 2006. ACM.
[12] Ambuj Tewari and Peter L. Bartlett. Optimistic linear programming gives logarithmic regret
for irreducible mdps. In Proceedings of Neural Information Processing Systems Conference
(NIPS), 2007.

9

