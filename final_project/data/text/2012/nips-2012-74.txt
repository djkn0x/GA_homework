Semi-Supervised Domain Adaptation with
Non-Parametric Copulas

David Lopez-Paz
MPI for Intelligent Systems
dlopez@tue.mpg.de

Jos ´e Miguel Hern ´andez-Lobato
University of Cambridge
jmh233@cam.ac.uk

Bernhard Sch ¨olkopf
MPI for Intelligent Systems
bs@tue.mpg.de

Abstract

A new framework based on the theory of copulas is proposed to address semi-
supervised domain adaptation problems. The presented method factorizes any
multivariate density into a product of marginal distributions and bivariate cop-
ula functions. Therefore, changes in each of these factors can be detected and
corrected to adapt a density model accross different learning domains.
Impor-
tantly, we introduce a novel vine copula model, which allows for this factorization
in a non-parametric manner. Experimental results on regression problems with
real-world data illustrate the efﬁcacy of the proposed approach when compared to
state-of-the-art techniques.

1

Introduction

When humans address a new learning problem, they often use knowledge acquired while learning
different but related tasks in the past. For example, when learning a second language, people rely on
grammar rules and word derivations from their mother tongue. This is called language transfer [19].
However, in machine learning, most of the traditional methods are not able to exploit similarities
between different learning tasks. These techniques only achieve good performance when the data
distribution is stable between training and test phases. When this is not the case, it is necessary to a)
collect and label additional data and b) re-run the learning algorithm. However, these operations are
not affordable in most practical scenarios.
Domain adaptation, transfer learning or multitask learning frameworks [17, 2, 5, 13] confront these
issues by ﬁrst, building a notion of task relatedness and second, providing mechanisms to transfer
knowledge between similar tasks. Generally, we are interested in improving predictive performance
on a target task by using knowledge obtained when solving another related source task. Domain
adaptation methods are concerned about what knowledge we can share between different tasks, how
we can transfer this knowledge and when we should do it or not to avoid additional damage [4].
In this work, we study semi-supervised domain adaptation for regression tasks. In these problems,
the object of interest (the mechanism that maps a set of inputs to a set of outputs) can be stated as
a conditional density function. The data available for solving each learning task is assumed to be
sampled from modiﬁed versions of a common multivariate distribution. Therefore, we are interested
in sharing the “common pieces” of this generative model between tasks, and use the data from
each individual task to detect, learn and adapt the varying parts of the model. To do so, we must
ﬁnd a decomposition of multivariate distributions into simpler building blocks that may be studied
separately across different domains. The theory of copulas provides such representations [18].
Copulas are statistical tools that factorize multivariate distributions into the product of its marginals
and a function that captures any possible form of dependence among them. This function is referred
to as the copula, and it links the marginals together into the joint multivariate model. Firstly intro-

1

duced by Sklar [22], copulas have been successfully used in a wide range of applications, including
ﬁnance, time series or natural phenomena modeling [12]. Recently, a new family of copulas named
vines have gained interest in the statistics literature [1]. These are methods that factorize multivari-
ate densities into a product of marginal distributions and bivariate copula functions. Each of these
factors corresponds to one of the building blocks that we assume either constant or varying across
different learning domains.
The contributions of this paper are two-fold. First, we propose a non-parametric vine copula model
which can be used as a high-dimensional density estimator. Second, by making use of this method,
we present a new framework to address semi-supervised domain adaptation problems, which per-
formance is validated in a series of experiments with real-world data and competing state-of-the-art
techniques.
The rest of the paper is organized as follows: Section 2 provides a brief introduction to copulas,
and describes a non-parametric estimator for the bivariate case. Section 3 introduces a novel non-
parametric vine copula model, which is formed by the described bivariate non-parametric copulas.
Section 4 describes a new framework to address semi-supervised domain adaptation problems using
the proposed vine method. Finally, section 5 describes a series of experiments that validate the
proposed approach on regression problems with real-world data.

2 Copulas

p(x) =

.

(1)

(2)

p(x) =

p(xi ) .

d(cid:89)
When the components of x = (x1 , . . . , xd ) are jointly independent, their density function p(x) can
be written as
i=1
This equality does not hold when x1 , . . . , xd are not independent. Nevertheless, the differences
can be corrected if we multiply the right hand side of (1) by a speciﬁc function that fully describes
d(cid:89)
any possible dependence between x1 , . . . , xd . This function is called the copula of p(x) [18] and
satisﬁes
(cid:124)
(cid:123)(cid:122)
(cid:125)
p(xi ) c(P (x1 ), ..., P (xd ))
i=1
copula
The copula c is the joint density of P (x1 ), . . . , P (xd ), where P (xi ) is the marginal cdf of the ran-
dom variable xi . This density has uniform marginals, since P (z ) ∼ U [0, 1] for any random variable
z . That is, when we apply the transformation P (x1 ), . . . , P (xd ) to x1 , . . . , xd , we are eliminating all
information about the marginal distributions. Therefore, the copula captures any distributional pat-
tern that does not depend on their speciﬁc form, or, in other words, all the information regarding the
dependencies between x1 , . . . , xd . When P (x1 ), . . . , P (xd ) are continuous, the copula c is unique
[22]. However, inﬁnitely many multivariate models share the same underlying copula function, as
illustrated in Figure 1. The main advantage of copulas is that they allow us to model separately the
marginal distributions and the dependencies linking them together to produce the multivariate model
subject of study.
Given a sample from (2), we can estimate p(x) as follows. First, we construct estimates of the
marginal pdfs, ˆp(x1 ), . . . , ˆp(xd ), which also provide estimates of the corresponding marginal cdfs,
ˆP (x1 ), . . . , ˆP (xd ). These cdfs estimates are used to map the data to the d-dimensional unit hyper-
cube. The transformed data are then used to obtain an estimate ˆc for the copula of p(x). Finally, (2)
d(cid:89)
is approximated as
i=1
The estimation of marginal pdfs and cdfs can be implemented in a non-parametric manner by using
unidimensional kernel density estimates. By contrast, it is common practice to assume a parametric
model for the estimation of the copula function. Some examples of parametric copulas are Gaussian,
Gumbel, Frank, Clayton or Student copulas [18]. Nevertheless, real-world data often exhibit com-
plex dependencies which cannot be correctly described by these parametric copula models. This
lack of ﬂexibility of parametric copulas is illustrated in Figure 2. As an alternative, we propose

ˆp(xi ) ˆc( ˆP (x1 ), ..., ˆP (xd )).

ˆp(x) =

(3)

2

Figure 1: Left, sample from a Gaussian copula with correlation ρ = 0.8. Middle and right, two
samples drawn from multivariate models with this same copula but different marginal distributions,
depicted as rug plots.

Figure 2: Left, sample from the copula linking variables 4 and 11 in the W IR EL E S S dataset. Middle,
density estimate generated by a Gaussian copula model when ﬁtted to the data. This technique is
unable to capture the complex patterns present in the data. Right, copula density estimate generated
by the non-parametric method described in section 2.1.

to approximate the copula function in a non-parametric manner. Kernel density estimates can also
be used to generate non-parametric approximations of copulas, as described in [8]. The following
section reviews this method for the two-dimensional case.

2.1 Non-parametric Bivariate Copulas

We now elaborate on how to non-parametrically estimate the copula of a given bivariate density
p(x, y). Recall that this density can be factorized as the product of its marginals and its copula

(4)
p(x, y) = p(x) p(y) c(P (x), P (y)).
Additionally, given a sample {(xi , yi )}n
i=1 from p(x, y), we can obtain a pseudo-sample from its
copula c by mapping each observation to the unit square using estimates of the marginal cdfs, namely
i=1 := {( ˆP (xi ), ˆP (yi ))}n
{(ui , vi )}n
(5)
i=1 .
These are approximate observations from the uniformly distributed random variables u = P (x) and
v = P (y), whose joint density is the copula function c(u, v). We could try to approximate this
density function by placing Gaussian kernels on each observation ui and vi . However, the resulting
density estimate would have support on R2 , while the support of c is the unit square. A solution
is to perform the density estimation in a transformed space. For this, we select some continuous
distribution with support on R, strictly positive density φ, cumulative distribution Φ and quantile
function Φ−1 . Let z and w be two new random variables given by z = Φ−1 (u) and w = Φ−1 (v).
Then, the joint density of z and w is

(6)
p(z , w) = φ(z ) φ(w) c(Φ(z ), Φ(w)) .
The copula of this new density is identical to the copula of (4), since the performed transforma-
tions are marginal-wise. The support of (6) is now R2 ; therefore, we can now approximate it with

3

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll0.000.250.500.751.000.000.250.500.751.00llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll0246−202llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll0.02.55.00.02.55.0llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll0.000.250.500.751.000.000.250.500.751.000255075100025507510002550751000255075100n(cid:88)
Gaussian kernels. Let zi = Φ−1 (ui ) and wi = Φ−1 (vi ). Then,
N (z , w|zi , wi , Σ),
1
(7)
ˆp(z , w) =
n
i=1
where N (·, ·|ν1 , ν2 , Σ) is a two-dimensional Gaussian density with mean (ν1 , ν2 ) and covariance
matrix Σ. For convenience, we select φ, Φ and Φ−1 to be the standard Gaussian pdf, cdf and
quantile function, respectively. Finally, the copula density c(u, v) is approximated by combining (6)
n(cid:88)
with (7):
N (Φ−1 (u), Φ−1 (v)|Φ−1 (ui ), Φ−1 (vi ), Σ)
φ(Φ−1 (u))φ(Φ−1 (v))
i=1

ˆp(Φ−1 (u), Φ−1 (v))
φ(Φ−1 (u))φ(Φ−1 (v))

ˆc(u, v) =

1
n

=

.

(8)

3 Regular Vines

The method described above can be generalized to the estimation of copulas of more than two ran-
dom variables. However, although kernel density estimates can be successful in spaces of one or two
dimensions, as the number of variables increases, this methods start to be signiﬁcantly affected by
the curse of dimensionality and tend to overﬁt to the training data. Additionally, for addressing do-
main adaptation problems, we are interested in factorizing these high-dimensional copulas into sim-
pler building blocks transferrable accross learning domains. These two drawbacks can be addressed
by recent methods in copula modelling called vines [1]. Vines decompose any high-dimensional
copula density as a product of bivariate copula densities that can be approximated using the non-
parametric model described above. These bivariate copulas (as well as the marginals) correspond to
the simple building blocks that we plan to transfer from one learning domain to another. Different
types of vines have been proposed in the literature. Some examples are canonical vines, D-vines
or regular vines [16, 1]. In this work we focus on regular vines (R-vines) since they are the most
general models.
An R-vine V for a probability density p(x1 , . . . , xd ) with variable set V = {1, . . . d} is formed
by a set of undirected trees T1 , . . . , Td−1 , each of them with corresponding set of nodes Vi and set
of edges Ei , where Vi = Ei−1 for i ∈ [2, d − 1] . Any edge e ∈ Ei has associated three sets
C (e), D(e), N (e) ⊂ V called the conditioned, conditioning and constraint sets of e, respectively.
Initially, T1 is inferred from a complete graph with a node associated with each element of V ; for any
e ∈ T1 joining nodes Vj and Vk , C (e) = N (e) = {Vj , Vk } and D(e) = {∅}. The trees T2 , ..., Td−1
are constructed so that each e ∈ Ei is formed by joining two edges e1 , e2 ∈ Ei−1 which share a
common node, for i ≥ 2. The new edge e has conditioned, conditioning and constraint sets given
by C (e) = N (e1 )∆N (e2 ), D(e) = N (e1 ) ∩ N (e1 ), N (e) = N (e1 ) ∪ N (e2 ), where ∆ is the
symmetric difference operator. Figure 3 illustrates this procedure for an R-vine with 4 variables.
For any edge e(j, k) ∈ Ti , i = 1, . . . , d − 1 with conditioned set C (e) = {j, k} and conditioning
set D(e) let cjk|D(e) be the value of the copula density for the conditional distribution of xj and xk
when conditioning on {xi : i ∈ D(e)}, that is,
cjk|D(e) := c(Pj |D(e) , Pk|D(e) |xi : i ∈ D(e)),
(9)
where Pj |D(e) := P (xj |xi : i ∈ D(e)) is the conditional cdf of xj when conditioning on {xi : i ∈
D(e)}. Kurowicka and Cooke [16] indicate that any probability density function p(x1 , . . . , xd ) can
(cid:89)
d−1(cid:89)
d(cid:89)
then be factorized as
(10)
cjk|D(e) ,
p(x) =
p(xi )
e(j,k)∈Ei
i=1
i=1
where E1 , . . . , Ed−1 are the edge sets of the R-vine V for p(x1 , . . . , xd ). In particular, each of the
edges in the trees from V specify a different conditional copula density in (10). For d variables, the
density in (10) is formed by d(d − 1)/2 factors. Changes in each of these factors can be detected
and independently transferred accross different learning domains to improve the estimation of the
target density function.
The deﬁnition of cjk|D(e) in (9) requires the calculation of conditional marginal cdfs. For this, we
use the following recursive identity introduced by Joe [14], that is,
∂ Cjk|D(e)\k
∂Pk|D(e)\k

Pj |D(e) =

(11)

,

4

Tree 1
1, 2|∅

1, 1|∅

1, 3|∅

Tree 2
2, 3|1

2, 2|∅

1, 2|∅

Tree 3
2, 4|1, 3

1, 3|∅

2, 3|1

1, 4|3

2, 4|∅

1, 4|3

3, 4|∅
(cid:124)
(cid:123)(cid:122)
(cid:125)
· c12 · c13 · c34
Tree 1

3, 3|∅

4, 4|∅
3, 4|∅
(cid:123)(cid:122)
(cid:124)
(cid:125)
p1234 = p1 · p2 · p3 · p4
Marginals

(cid:124) (cid:123)(cid:122) (cid:125)
(cid:123)(cid:122)
(cid:124)
(cid:125)
· c23|1 · c14|3
· c24|13
Tree 2
Tree 3
Figure 3: Example of the hierarchical construction of a R-vine copula for a system of four variables.
The edges selected to form each tree are highlighted in bold. Conditioned and conditioning sets for
each node and edge are shown as C (e)|D(e). Later, each edge in bold will correspond to a different
bivariate copula function.

which holds for any k ∈ D(e), where D(e) \ k = {i : i ∈ D(e) ∧ i (cid:54)= k} and Cjk|D(e)\k is the cdf
of cjk|D(e)\k .
One major advantage of vines is that they can model high-dimensional data by estimating density
functions of only one or two random variables. For this reason, these techniques are signiﬁcantly
less affected by the curse of dimensionality than regular density estimators based on kernels, as we
show in Section 5. So far Vines have been generally constructed using parametric models for the
estimation of bivariate copulas. In the following, we describe a novel method for the construction
of non-parametric regular vines.

3.1 Non-parametric Regular Vines

1
nφ(w)

In this section, we introduce a vine distribution in which all participant bivariate copulas can be
estimated in a non-parametric manner. Todo so, we model each of the copulas in (10) using the non-
parametric method described in Section 2.1. Let {(ui , vi )}n
i=1 be a sample from the copula density
c(u, v). The basic operation needed for the implementation of the proposed method is the evaluation
of the conditional cdf P (u|v) using the recursive equation (11). Deﬁne w = Φ−1 (v), zi = Φ−1 (ui )
(cid:90) u
and wi = Φ−1 (vi ). Combining (8) and (11) we obtain
ˆP (u|v) =
(cid:90) u
n(cid:88)
ˆc(x, v) dx
0
n(cid:88)
0
i=1
N (w|wi , σ2
w ) Φ
i=1
where N (·|µ, σ2 ) denotes a Gaussian density with mean µ and variance σ2 , Σ =
γ (w − wi ) and σ2
z (1 − γ 2 ).
kernel bandwidth matrix, µzi |wi = zi + σz
= σ2
zi |wi
σw
Equation (12) can be used to approximate any conditional cdf Pj |D(e) . For this, we use the fact that
P (xj |xi : i ∈ D(e)) = P (uj |ui : i ∈ D(e)), where ui = P (xi ), for i = 1, . . . , d, and recursively
apply rule (11) using equation (12) to compute ˆP (uj |ui : i ∈ D(e)).
To complete the inference recipe for the non-parametric regular vine, we must specify how to con-
struct the hierarchy of trees T1 , . . . , Td−1 . In other words, we must deﬁne a procedure to select the
edges (bivariate copulas) that will form each tree. We have a total of d(d − 1)/2 bivariate copulas

N (Φ−1 (x), w|zi , wi , Σ)
(cid:34)
dx
φ(Φ−1 (x))
Φ−1 (u) − µzi |wi
σ2
zi |wi

(cid:18) σ2
z
γ

(12)
(cid:19)

1
nφ(w)

(cid:35)

,

γ
σ2
w

the

=

=

5

which should be distributed among the different trees. Ideally, we would like to include in the ﬁrst
trees of the hierarchy the copulas with strongest dependence level. This will allow us to prune the
model by assuming independence in the last k < d trees, since the density function for the inde-
pendent copula is constant and equal to 1. To construct the trees T1 , . . . , Td−1 , we assign a weight
to each edge e(j, k) (copula) according to the level of dependence between the random variables xj
and xk . A common practice is to ﬁx this weight to the empirical estimate of Kendall’s’ τ for the two
random variables under consideration[1]1 . Given these weights for each edge, we propose to solve
the edge selection problem by obtaining d − 1 maximum spanning trees. Prim’s Algorithm [20] can
be used to solve this problem efﬁciently.

4 Domain Adaptation with Regular Vines

In this section we describe how regular vines can be used to address domain adaptation problems
in the non-linear regression setting with continuous data. The proposed approach could be easily
extended to other problems such as density estimation or classiﬁcation. In regression problems, we
are interested in inferring the mapping mechanism or conditional distribution with density p(y |x)
that maps one feature vector x = (x1 , . . . , xd ) ∈ Rd into a target scalar value y ∈ R. Rephrased
into the copula framework, this conditional density can be expressed as
(cid:89)
d(cid:89)
e(j,k)∈Ei
i=1

p(y |x) ∝ p(y)

cjk|D(e)

(13)

where E1 , . . . , Ed are the edge sets of an R-vine for p(x, y). Note that the normalization of the right
part of (13) is relatively easy since y is scalar.
In the classic domain adaptation setup we usually have large amounts of data for solving a source
task characterized by the density function ps (x, y). However, only a partial or reduced sample is
available for solving a target task with density pt (x, y). Given the data available for both tasks, our
objective is to build a good estimate for the conditional density pt (y |x). To address this domain
adaptation problem, we assume that pt is a modiﬁed version of ps . In particular, we assume that
pt is obtained in two steps from ps . First, ps is expressed using an R-vine representation as in (10)
and second, some of the factors included in that representation (marginal distributions or pairwise
copulas) are modiﬁed to derive pt . All we need to address the adaptation across domains is to
reconstruct the R-vine representation of ps using data from the source task, and then identify which
of the factors have been modiﬁed to produce pt . These factors are corrected using data from the
target task. In the following, we describe how to identify and correct these modiﬁed factors.
Marginal distributions can change between source and target tasks (also known as covariate shift).
In this case, Ps (xi ) (cid:54)= Pt (xi ), for i = 1, . . . , d, or Ps (y) (cid:54)= Pt (y), and we need to re-generate
the estimates of the affected marginals using data from the target task. Additionally, some of the
bivariate copulas cjk|D(e) may differ from source to target tasks. In this case, we also re-estimate
the affected copulas using data from the target task. Simultaneous changes in both copulas and
marginals can occur. However, there is no limitation in updating each of the modiﬁed components
separately. Finally, if some of the factors remain constant across domains, we can use the available
data from the target task to improve the estimates obtained using only the data from the source
task. Note that we are addressing a more general problem than covariate shift. Besides identifying
and correcting changes in marginal distributions, we also consider changes in any possible form of
dependence (conditional distributions) between random variables.
For the implementation of the strategy mentioned above, we need to identify when two samples
come from the same distribution or not. For this, we propose to use the non-parametric two-sample
test Maximum Mean Discrepancy (MMD) [10]. MMD will return low p-values when two samples
are unlikely to have been drawn from the same distribution. Speciﬁcally, given samples from two
distributions P and Q, MMD will determine P (cid:54)= Q if the distance between the embeddings of the
empirical distributions for these two samples in a RKHS is signiﬁcantly large.

1We have tried more general dependence measures such as the HSIC (Hilbert-Schmidt Independence Crite-
rion) without observing gains that justify the increase of computational costs.

6

Table 1: Average TLL obtained by NPRV , GRV and KDE on six different UCI datasets.

Dataset
No. of variables
KDE
GRV
NPRV

Auto
8
1.32 ± 0.06
1.84 ± 0.08
2.07 ± 0.07

Cloud
10
3.25 ± 0.10
5.00 ± 0.12
4.54 ± 0.13

Housing
14
1.96 ± 0.17
1.68 ± 0.11
3.18 ± 0.17

Magic
11
1.13 ± 0.11
2.09 ± 0.08
2.72 ± 0.17

Page-Blocks Wireless
10
11
0.98 ± 0.06
1.90 ± 0.13
0.36 ± 0.08
4.69 ± 0.20
5.64 ± 0.14
2.17 ± 0.13

Semi-supervised and unsupervised domain adaptation: The proposed approach can be easily
extended to take advantage of additional unlabeled data to improve the estimation of our model.
Speciﬁcally, extra unlabeled target task data can be used to reﬁne the factors in the R-Vine decom-
position of pt which do not depend on y . This is still valid even in the limiting case of not having
access to labeled data from the target task at training time (unsupervised domain adaptation).

5 Experiments

To validate the proposed method, we run two series of experiments using real world data. The ﬁrst
series illustrates the accuracy of the density estimates generated by the proposed non-parametric
vine method. The second series validates the effectiveness of the proposed framework for domain
adaptation problems in the non-linear regression setting. In all experiments, kernel bandwidth ma-
trices are selected using Silverman’s rule-of-thumb [21]. For comparative purposes, we include the
results of different state-of-the-art domain adaptation methods whose parameters are selected by a
10-fold cross validation process on the training data.

Approximations: A complete R-Vine requires the use of conditional copula functions, which are
challenging to learn. A common approximation is to ignore any dependence between the copula
functional form and its set of conditioning variables. Note that the copula functions arguments re-
main to be conditioned cdfs. Moreover, to avoid excesive computational costs, we consider only
the ﬁrst tree (d − 1 copulas) of the R-Vine, which is the one containing the most amount of depen-
dence between the distribution variables. Increasing the number of considered trees did not lead to
signiﬁcant performance improvements.

5.1 Accuracy of Non-parametric Regular Vines for Density Estimation

The density estimates generated by the new non-parametric R-vine method (NPRV) are evaluated on
data from six normalized UCI datasets [9]. We compare against a standard density estimator based
on Gaussian kernels (KDE), and a parametric vine method based on bivariate Gaussian copulas
(GRV). From each dataset, we extract 50 random samples of size 1000. Training is performed using
30% of each random sample. Average test log-likelihoods and corresponding standard deviations
on the remaining 70% of the random sample are summarized in Table 1 for each technique. In these
experiments, NPRV obtains the highest average test log-likelihood in all cases except one, where it
is outperformed by GRV. KDE shows the worst performance, due to its direct exposure to the curse
of dimensionality.

5.2 Comparison with other Domain Adaptation Methods

NPRV is analyzed in a series of experiments for domain adaptation on the non-linear regression
setting with real-world data. Detailed descriptions of the 6 UCI selected datasets and their domains
are available in the supplementary material. The proposed technique is compared with different
benchmark methods. The ﬁrst two, GP -SOURC E and GP -A LL, are considered baselines. They are
two gaussian process (GP) methods, the ﬁrst one trained only with data from the source task, and
the second one trained with the normalized union of data from both source and target problems.
The other ﬁve methods are considered state-of-the-art domain adaptation techniques. DAUM E [7]
performs a feature augmentation such that the kernel function evaluated at two points from the same

7

Table 2: Average NMSE and standard deviation for all algorithms and UCI datasets.

Dataset
No. of variables
GP-Source
GP-All
Daume
SSL-Daume
ATGP
KMM
KuLSIF
NPRV
UNPRV
Av. Ch. Mar.
Av. Ch. Cop.

Wine
12
0.86 ± 0.02
0.83 ± 0.03
0.97 ± 0.03
0.82 ± 0.05
0.86 ± 0.08
1.03 ± 0.01
0.91 ± 0.08
0.73 ± 0.07
0.76 ± 0.06
10
5

Sarcos
21
1.80 ± 0.04
1.69 ± 0.04
0.88 ± 0.02
0.74 ± 0.08
0.79 ± 0.07
1.00 ± 0.00
1.67 ± 0.06
0.61 ± 0.10
0.62 ± 0.13
1
8

Rocks-Mines Hill-Valleys
60
100
1.00 ± 0.00
0.90 ± 0.01
0.87 ± 0.06
1.10 ± 0.08
0.99 ± 0.03
0.72 ± 0.09
0.82 ± 0.07
0.59 ± 0.07
0.56 ± 0.10
0.15 ± 0.07
1.00 ± 0.00
1.00 ± 0.00
0.80 ± 0.11
0.65 ± 0.10
0.15 ± 0.07
0.72 ± 0.13
0.72 ± 0.15
0.19 ± 0.09
100
38
49
34

Axis-Slice
386
1.52 ± 0.02
1.27 ± 0.07
0.95 ± 0.02
0.65 ± 0.04
1.00 ± 0.01
1.00 ± 0.00
0.98 ± 0.07
0.38 ± 0.07
0.37 ± 0.07
226
155

Isolet
617
1.59 ± 0.02
1.58 ± 0.02
0.99 ± 0.00
0.64 ± 0.02
1.00 ± 0.00
1.00 ± 0.00
0.58 ± 0.02
0.46 ± 0.09
0.42 ± 0.04
89
474

domain is twice larger than when these two points come from different domains. SSL -DAUM E [6] is
a SSL extension of DAUM E which takes into account unlabeled data from the target domain. ATGP
[4] models the source and target task data using a single GP, but learns additional kernel parameters
to correlate input vectors between domains. This method outperforms others like the one proposed
by Bonilla et al. [3]. KMM [11] minimizes the distance of marginal distributions in source and
target domains by matching their means when mapped into an universal RKHS. Finally, KULS IF
[15] operates in a similar way as KMM . Besides NPRV , we also include in the experiments its fully
unsupervised variant, UNPRV, which ignores any labeled data from the target task.
For training, we randomly sample 1000 data points for both source and target tasks, where all the
data in the source task and 5% of the data in the target task are labeled. The test set contains 1000
points from the target task. Table 2 summarizes the average test normalized mean square error
(NMSE) and corresponding standard deviation for each method in each dataset across 30 random
repetitions of the experiment. The proposed methods obtain the best results in 5 out of 6 cases.
Notably, UNPRV (Unsupervised NPRV), which ignores labeled data from the target task, also
outperforms the other benchmark methods in most cases. Finally, the two bottom rows in Table
2 show the average number of marginals and bivariate copulas which are updated in each dataset
during the execution of NPRV, respectively.
Computational Costs: Running NPRV requires to ﬁll in a weight matrix of size O(d2 ) with
the empirical estimates of Kendall’s τ for any two random variables. The computation of each of
these estimates can be done efﬁciently with cost O(n log n), where n is the number of available
data points. Therefore, the ﬁnal training cost of NPRV is O(d2n log n). In practice, we obtain
competitive training times. Training NPRV for the Isolet dataset took about 3 minutes on a regular
laptop computer. Predictions made by a single level NPRV have cost O(nd). Parametric copulas
may be used to reduce the computational demands.

6 Conclusions

We have proposed a novel non-parametric domain adaptation strategy based on copulas. The new
approach works by decomposing any multivariate density into a product of marginal densities and
bivariate copula functions. Changes in these factors across different domains can be detected using
two sample tests, and transferred across domains in order to adapt the target task density model.
A novel non-parametric vine method has been introduced for the practical implementation of this
method. This technique leads to better density estimates than standard parametric vines or KDE, and
is also able to outperform a large number of alternative domain adaptation methods in a collection
of regression problems with real-world data.

8

References
[1] K. Aas, C. Czado, A. Frigessi, and H. Bakken. Pair-copula constructions of multiple depen-
dence. Insurance: Mathematics and Economics, 44(2):182–198, 2006.
[2] S. Ben-David, J. Blitzer, K. Crammer, A. Kulesza, F. Pereira, and J. Wortman. A theory of
learning from different domains. Machine Learning, 79(1):151–175, 2010.
[3] E. Bonilla, K. Chai, and C. Williams. Multi-task gaussian process prediction. NIPS, 2008.
[4] B. Cao, S. Jialin, Y. Zhang, D. Yeung, and Q. Yang. Adaptive transfer learning. AAAI, 2010.
[5] C. Cortes and M. Mohri. Domain adaptation in regression. In Proceedings of the 22nd interna-
tional conference on Algorithmic learning theory, ALT’11, pages 308–323, Berlin, Heidelberg,
2011. Springer-Verlag.
[6] H. Daum ´e, III, Abhishek Kumar, and Avishek Saha. Frustratingly easy semi-supervised do-
main adaptation. Proceedings of the 2010 Workshop on Domain Adaptation for Natural Lan-
guage Processing, pages 53–59, 2010.
[7] H. Daum ´e III. Frustratingly easy domain adaptation. Association of Computational Linguistics,
pages 256–263, 2007.
[8] J. Fermanian and O. Scaillet. The estimation of copulas: Theory and practice. Copulas: From
Theory to Application in Finance, pages 35–60, 2007.
[9] A. Frank and A. Asuncion. UCI machine learning repository, 2010.
[10] A. Gretton, K. Borgwardt, M. Rasch, B. Scholkopf, and A. Smola. A kernel method for the
two-sample-problem. NIPS, pages 513–520, 2007.
[11] J. Huang, A. Smola, A. Gretton, K. Borgwardt, and B. Schoelkopf. Correcting sample selection
bias by unlabeled data. NIPS, pages 601–608, 2007.
[12] P. Jaworski, F. Durante, W.K. H ¨ardle, and T. Rychlik. Copula Theory and Its Applications.
Lecture Notes in Statistics. Springer, 2010.
[13] S. Jialin-Pan and Q. Yang. A survey on transfer learning. IEEE Transactions on Knowledge
and Data Engineering, 22(10):1345–1359, 2010.
[14] H. Joe. Families of m-variate distributions with given margins and m(m − 1)/2 bivariate
dependence parameters. Distributions with Fixed Marginals and Related Topics, 1996.
[15] T. Kanamori, T. Suzuki, and M. Sugiyama. Statistical analysis of kernel-based least-squares
density-ratio estimation. Machine Learning, 86(3):335–367, 2012.
[16] D. Kurowicka and R. Cooke. Uncertainty Analysis with High Dimensional Dependence Mod-
elling. Wiley Series in Probability and Statistics, 1st edition, 2006.
[17] Y. Mansour, M. Mohri, and A. Rostamizadeh. Domain adaptation: Learning bounds and algo-
rithms. In COLT, 2009.
[18] R. Nelsen. An Introduction to Copulas. Springer Series in Statistics, 2nd edition, 2006.
[19] S. Nitschke, E. Kidd, and L. Serratrice. First language transfer and long-term structural priming
in comprehension. Language and Cognitive Processes, 5(1):94–114, 2010.
[20] R. C. Prim. Shortest connection networks and some generalizations. Bell System Technology
Journal, 36:1389–1401, 1957.
[21] B.W. Silverman. Density Estimation for Statistics and Data Analysis. Monographs on Statistics
and Applied Probability. Chapman and Hall, 1986.
[22] A. Sklar. Fonctions de repartition `a n dimension set leurs marges. Publ. Inst. Statis. Univ.
Paris, 8(1):229–231, 1959.

9

