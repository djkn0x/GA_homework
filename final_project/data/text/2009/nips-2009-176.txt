Rank-Approximate Nearest Neighbor Search:
Retaining Meaning and Speed in High Dimensions

Parikshit Ram, Dongryeol Lee, Hua Ouyang and Alexander G. Gray
Computational Science and Engineering, Georgia Institute of Technology
Atlanta, GA 30332
{p.ram@,dongryel@cc.,houyang@,agray@cc.}gatech.edu

Abstract

The long-standing problem of efﬁcient nearest-neighbor (N N) search has ubiqui-
tous applications ranging from astrophysics to MP3 ﬁngerpr inting to bioinformat-
ics to movie recommendations. As the dimensionality of the dataset increases, ex-
act NN search becomes computationally prohibitive; (1 + ) distance-approximate
NN search can provide large speedups but risks losing the meaning of NN search
present in the ranks (ordering) of the distances. This paper presents a simple,
practical algorithm allowing the user to, for the ﬁrst time, directly control the
true accuracy of NN search (in terms of ranks) while still achieving the large
speedups over exact NN. Experiments on high-dimensional datasets show that
our algorithm often achieves faster and more accurate results than the best-known
distance-approximate method, with much more stable behavior.

1

Introduction

In this paper, we address the problem of nearest-neighbor (NN) search in large datasets of high
dimensionality. It is used for classi ﬁcation ( -NN classi ﬁer [1]), categorizing a test point on the ba-
sis of the classes in its close neighborhood. Non-parametric density estimation uses NN algorithms
when the bandwidth at any point depends on the  ℎ NN distance (NN kernel density estimation [2]).
NN algorithms are present in and often the main cost of most non-linear dimensionality reduction
techniques (manifold learning [3, 4]) to obtain the neighborhood of every point which is then pre-
served during the dimension reduction. NN search has extensive applications in databases [5] and
computer vision for image search Further applications abound in machine learning.

Tree data structures such as -trees are used for efﬁcient exact NN search but do not scale b etter
than the na¨ıve linear search in sufﬁciently high dimensions. Distance -approximate NN (DANN)
search, introduced to increase the scalability of NN search, approximates the distance to the NN and
any neighbor found within that distance is considered to be “ good enough”. Numerous techniques
exist to achieve this form of approximation and are fairly scalable to higher dimensions under certain
assumptions.

Although the DANN search places bounds on the numerical values of the distance to NN, in NN
search, distances themselves are not essential; rather the order of the distances of the query to the
points in the dataset captures the necessary and sufﬁcient i nformation [6, 7]. For example, consider
the two-dimensional dataset (1, 1), (2, 2), (3, 3), (4, 4), . . . with a query at the origin. Appending
non-informative dimensions to each of the reference points produces higher dimensional datasets
of the form (1, 1, 1, 1, 1, ....), (2, 2, 1, 1, 1, ...), (3, 3, 1, 1, 1, ...), (4, 4, 1, 1, 1, ...), . . .. For a ﬁxed dis-
tance approximation, raising the dimension increases the number of points for which the distance to
the query (i.e. the origin) satis ﬁes the approximation cond ition. However, the ordering (and hence
the ranks) of those distances remains the same. The proposed framework, rank-approximate nearest-
neighbor (RANN) search, approximates the NN in its rank rather than in its distance, thereby making
the approximation independent of the distance distribution and only dependent on the ordering of
the distances.

1

This paper is organized as follows: Section 2 describes the existing methods for exact NN and
DANN search and the challenges they face in high dimensions. Section 3 introduces the proposed
approach and provides a practical algorithm using strati ﬁe d sampling with a tree data structure to
obtain a user-speci ﬁed level of rank approximation in Eucli dean NN search. Section 4 reports the
experiments comparing RANN with exact search and DANN. Finally, Section 5 concludes with
discussion of the road ahead.

2 Related Work

The problem of NN search is formalized as the following:
Problem. Given a dataset  ⊂  of size  in a metric space (, ) and a query  ∈  , efﬁciently
ﬁnd a point  ∈  such that
(1)
(, ) = min
(, ).
∈

2.1 Exact Search

The simplest approach of linear search over  to ﬁnd the NN is easy to implement, but requires
O( ) computations for a single NN query, making it unscalable for moderately large  .
Hashing the dataset into buckets is an efﬁcient technique, b ut scales only to very low dimensional
 . Hence data structures are used to answer queries efﬁcientl y. Binary spatial partitioning trees,
like -trees [9], ball trees [10] and metric trees [11] utilize the triangular inequality of the distance
metric  (commonly the Euclidean distance metric) to prune away parts of the dataset from the com-
putation and answer queries in expected O(log  ) computations [9]. Non-binary cover trees [12]
answer queries in theoretically bounded O(log  ) time using the same property under certain mild
assumptions on the dataset.

Finding NNs for O( ) queries would then require at least O( log  ) computations using the
trees. The dual-tree algorithm [13] for NN search also builds a tree on the queries instead of going
through them linearly, hence amortizing the cost of search over the queries. This algorithm shows
orders of magnitude improvement in efﬁciency and is conject ured to be O( ) for answering O( )
queries using the cover trees [12].

2.2 Nearest Neighbors in High Dimensions

The frontier of research in NN methods is high dimensional problems, stemming from common
datasets like images and documents to microarray data. But high dimensional data poses an inherent
problem for Euclidean NN search as described in the following theorem:
Theorem 2.1.
[8] Let  be a -dimensional hypersphere with radius . Let  and  be any two
points chosen at random in  , the distributions of  and  being independent and uniform over the
interior of  . Let  be the Euclidean distance between  and  ( ∈ [0, 2]). Then the asymptotic
distribution of  is  (√2, 2 /2).
This implies that in high dimensions, the Euclidean distances between uniformly distributed points
lie in a small range of continuous values. This hypothesizes that the tree based algorithms perform
no better than linear search since these data structures would be unable to employ sufﬁciently tight
bounds in high dimensions. This turns out to be true in practice [14, 15, 16]. This prompted interest
in approximation of the NN search problem.

2.3 Distance-Approximate Nearest Neighbors

The problem of NN search is relaxed in the following form to make it more scalable:
Problem. Given a dataset  ⊂  of size  in some metric space (, ) and a query  ∈  ,
′ ∈  such that
efﬁciently ﬁnd any point
(′ , ) ≤ (1 + ) min
∈
for a low value of  ∈ ℝ+ with high probability.
This approximation can be achieved with -trees, balls trees, and cover trees by modifying the
search algorithm to prune more aggressively. This introduces the allowed error while providing
some speedup over the exact algorithm [12]. Another approach modi ﬁes the tree data structures to

(, )

(2)

2

bound error with just one root-to-leaf traversal of the tree, i.e. to eliminate backtracking. Sibling
nodes in -trees or ball-trees are modi ﬁed to share points near their b oundaries, forming spill
trees [14]. These obtain signi ﬁcant speed up over the exact method s. The idea of approximately
correct (satisfying Eq. 2) NN is further extended to a formulation where the (1 + ) bound can be
exceeded with a low probability  , thus forming the PAC-NN search algorithms [17]. They provide
1-2 orders of magnitude speedup in moderately large datasets with suitable  and  .
These methods are still unable to scale to high dimensions. However, they can be used in combina-
tion with the assumption that high dimensional data actually lies on a lower dimensional subspace.
There are a number of fast DANN methods that preprocess data with randomized projections to
reduce dimensionality. Hybrid spill trees [14] build spill trees on the randomly projected data to
obtain signi ﬁcant speedups. Locality sensitive hashing [18, 19] hashes the data into a lower dimen-
sional buckets using hash functions which guarantee that “c lose” points are hashed into the same
bucket with high probability and “farther apart ” points are
hashed into the same bucket with low
probability. This method has signi ﬁcant improvements in ru nning times over traditional methods in
high dimensional data and is shown to be highly scalable.

However, the DANN methods assume that the distances are well behaved and not concentrated in a
small range. However, for example, if the all pairwise distances are within the range (100.0, 101.00),
any distance approximation  ≥ 0.01 will return an arbitrary point to a NN query. The exact tree-
based algorithms failed to be efﬁcient because many dataset s encountered in practice suffered the
same concentration of pairwise distances. Using DANN in such a situation leads to the loss of the
ordering information of the pairwise distances which is essential for NN search [6]. This is too
large of a loss in accuracy for increased efﬁciency. In order
to address this issue, we propose a
model of approximation for NN search which preserves the information present in the ordering of
the distances by controlling the error in the ordering itself irrespective of the dimensionality or the
distribution of the pairwise distances in the dataset. We also provide a scalable algorithm to obtain
this form of approximation.

3 Rank Approximation

To approximate the NN rank, we formulate and relax NN search in the following way:
Problem. Given a dataset  ⊂  of size  in a metric space (, ) and a query  ∈  , let
 = {1 , . . . ,  } be the set of distances between the query and all the points in the dataset  ,
such that  = ( , ),  ∈ ,  = 1, . . . ,  . Let () be the ℎ order statistic of  . Then the
 ∈  : (, ) = (1) is the NN of  in  . The rank-approximation of NN search would then be to
′ ∈  such that
efﬁciently ﬁnd a point
(′ , ) ≤ (1+ )
with high probability for a given value of  ∈ ℤ+ .
RANN search may use any order statistics of the population  , bounded above by the (1 +  )ℎ
order statistics, to answer a NN query. Sedransk et.al. [20] provide a probability bound for the
sample order statistics bound on the order statistics of the whole set.
Theorem 3.1. For a population of size  with  values ordered as (1) ≤ (2) ⋅ ⋅ ⋅ ≤ ( ) , let
(1) ≤ (2) ⋅ ⋅ ⋅ ≤ () be a ordered sample of size  drawn from the population uniformly without
replacement. For 1 ≤  ≤  and 1 ≤  ≤ ,
−
  .
 −   /  
 − 1    −  + 
  −  − 1
ࢣ=0
 (() ≤ () ) =
We may ﬁnd a ′ ∈  satisfying Eq. 3 with high probability by sampling enough points {1 , . . .  }
from  such that for some 1 ≤  ≤ , rank error bound  , and a success probability 
 ((′ , ) = () ≤ (1+ ) ) ≥ .
(5)
Sample order statistic  = 1 minimizes the required number of samples; hence we substitute the
values of  = 1 and  = 1 +  in Eq. 4 obtaining the following expression which can be computed
in O( ) time

(3)

(4)

 ((1) ≤ (1+ ) ) =


ࢣ=0

  −  +  − 1
 − 1

  .
 /  

(6)

3

The required sample size  for a particular error  with success probability  is computed using
binary search over the range (1 +  ,  ]. This makes RANN search O() (since now we only need
to compute the ﬁrst order statistics of a sample of size ) giving O(/) speedup.

3.1 Strati ﬁed Sampling with a Tree

For a required sample size of , we randomly sample  points from  and compute the RANN for a
query  by going through the sampled set linearly. But for a tree built on  , parts of the tree would
be pruned away for the query  during the tree traversal. Hence we can ignore the random samples
from the pruned part of the tree, saving us some more computation.
Hence let  be in the form of a binary tree (say -tree) rooted at  . The root node has 
points. Let the left and right child have  and  points respectively. For a random query  ∈  ,
the population  is the set of distances of  to all the  points in  . The tree strati ﬁes the
population  into  = {1 , . . . ,  } and  = {1 , . . . ,  }, where  and  are the
set of distances of  to all the  and  points respectively in the left and right child of the root
node  . The following theorem provides a way to decide how much to sample from a particular
node, subsequently providing a lower bound on the number of samples required from the unpruned
part of the tree without violating Eq.5
Theorem 3.2. Let  and  be the number of random samples from the strata  and  respec-
tively by doing a strati ﬁed sampling on the population  of size  =  +  . Let  samples be
required for Eq.5 to hold in the population  for a given value of . Then Eq.5 holds for  with the
same value of  with the random samples of sizes  and  from the random strata  and  of
 respectively if  +  =  and  :  =  :  .

Proof. Eq. 5 simply requires  uniformly sampled points, i.e.
for each distance in  to have
probability / of inclusion. For  +  =  and  :  =  :  , we have  = ⌈(/ ) ⌉
and similarly  = ⌈(/ ) ⌉, and thus samples in both  and  are included at the proper rate.
Since the ratio of the sample size to the population size is a constant  = / , Theorem 3.2 is
generalizable to any level of the tree.

3.2 The Algorithm

The proposed algorithm introduces the intended approximation in the unpruned portion of the -
tree since the pruned part does not add to the computation in the exact tree based algorithms. The
algorithm starts at the root of the tree. While searching for the NN of a query  in a tree, most of
the computation in the traversal involves computing the distance of the query  to any tree node
 (  ( , )). If the current upperbound to the NN distance (()) for the query  is
greater than   ( , ), the node is traversed and () is updated. Otherwise node  is
pruned. The computations of distance of  to points in the dataset  occurs only when  reaches
a leaf node it cannot prune. The NN candidate in that leaf is computed using the linear search
(COM PU T EBRU T ENN subroutine in Fig.2). The traversal of the exact algorithm in the tree is illus-
trated in Fig.1.

To approximate the computation by sampling, traversal down the tree is stopped at a node which can
be summarized with a small number of samples (below a certain threshold MAXSAM P L E S). This is
illustrated in Fig.1. The value of MAXSAM P L E S giving maximum speedup can be obtained by cross-
validation. If a node is summarizable within the desired error bounds (decided by the CANA P PROX -
IMAT E subroutine in Fig.2), required number of points are sampled from such a node and the nearest
neighbor candidate is computed from among them using linear search (COM PU T EA P PROXNN sub-
routine of Fig.2).
Single Tree. The search algorithm is presented in Fig.2. The dataset  is stored as a binary tree
rooted at  . The algorithm starts as STRANKA P PROXNN( , ,  , ). During the search, if a
leaf node is reached (since the tree is rarely balanced), the exact NN candidate is computed. In case
a non-leaf node cannot be approximated, the child node closer to the query is always traversed ﬁrst.
The following theorem proves the correctness of the algorithm.
Theorem 3.3. For a query  and a speci ﬁed value of  and  , STRANKA P PROXNN( , ,  , )
computes a neighbor in  within (1 +  ) rank with probability at least .

4

Figure 1: The traversal paths of the exact and the rank-approximate algorithm in a -tree

Proof. By Eq.6, a query requires at least  samples from a dataset of size  to compute a neighbor
within (1 +  ) rank with a probability . Let  = (/ ). Let a node  contain ∣∣ points. In the
algorithm, sampling occurs when a base case of the recursion is reached. There are three base cases:

∙ Case 1 - Exact Pruning (if () ≤   ( , )): Then number of points required
to be sampled from the node is at least ⌈ ⋅ ∣∣⌉. However, since this node is pruned, we
ignore these points. Hence nothing is done in the algorithm.
∙ Case 2 - Exact Computation COM PU T EBRU T ENN( , )): In this subroutine, linear search
ly sampled is ∣∣ ≥
is used to ﬁnd the NN candidate. Hence number of points actual
⌈ ⋅ ∣∣⌉.
∙ Case 3 - Approximate Computation (COM PU T EA P PROXNN( , ,  )): In this subroutine,
exactly  ⋅ ∣∣ samples are made and linear search is performed over them.
Let the total number of points effectively sampled from  be ′ . From the three base cases of the
algorithm, it is conﬁrmed that ′ ≥ ⌈ ⋅  ⌉ = . Hence the algorithm computes a NN within (1 +  )
rank with probability at least .
Dual Tree. The single tree algorithm in Fig.2 can be extended to the dual tree algorithm in case
of O( ) queries. The dual tree RANN algorithm (DTRANKA P PROXNN( , ,  , )) is given in
Fig.2. The only difference is that for every query  ∈  , the minimum required amount of sampling
is done and the random sampling is done separately for each of the queries. Even though the queries
do not share samples from the reference set, when a query node of the query tree prunes a reference
node, that reference node is pruned for all the queries in that query node simultaneously. This
work-sharing is a key feature of all dual-tree algorithms [13].

4 Experiments and Results

A meaningful value for the rank error  should be relative to the size of the reference dataset  .
Hence for the experiments, the (1 +  )-RANN is modi ﬁed to (1 + ⌈ ⋅  ⌉)-RANN where 1.0 ≥
 ∈ ℝ+ . The Euclidean metric is used in all the experiments. Although the value of MAXSAM P L E S
for maximum speedup can be obtained by cross-validation, for practical purposes, any low value (≈
20-30) sufﬁces well, and this is what is used in the experimen ts.

4.1 Comparisons with Exact Search

The speedups of the exact dual-tree NN algorithm and the approximate tree-based algorithm over
the linear search algorithm is computed and compared. Different levels of approximations ranging
from 0.001% to 10% are used to show how the speedup increases with increase in approximation.

5

STRANKA P PROXNN( , ,  , )
 ←COM PU T ESAM P L ES I Z E (∣ ∣,  , )
 ← /∣ ∣
 ←TR E E( )
S TRANN( ,  ,  )
STRANN( , ,  )
if () >   ( , ) then
if I SL EA F() then
COM PU T EBRU T ENN( , )
else
if CANA P PROX IMAT E(,  )
then
COM PU T EA P PROXNN ( , ,  )
else
S TRANN( ,  ,  ),
S TRANN( ,  ,  )
end if
end if
COM PU T EBRU T ENN( , )
() ← min(min
∈
COM PU T EBRU T ENN(, )
for ∀ ∈  do
() ← min(min
∈
end for
 () ← max
∈
COM PU T EA P PROXNN( , ,  )
′ ← ⌈ ⋅ ∣∣⌉ samples from 
COM PU T EBRU T ENN( , ′ )
COM PU T EA P PROXNN(, ,  )
for ∀ ∈  do
′ ← ⌈ ⋅ ∣∣⌉ samples from 
COM PU T EBRU T ENN( , ′ )
end for
 () ← max
∈

( , ), ())

()

( , ), ())

()

DTRANKA P PROXNN( , ,  , )
 ←COM PU T ESAM P L ES I Z E (∣ ∣,  , )
 ← /∣ ∣
 ←TR E E( )
 ←TR E E( )
D TRANN( ,  ,  )
DTRANN(, ,  )
if  () >
  (, ) then
if I SL EA F() && I SL EA F() then
COM PU T EBRU T ENN(, )
else if I SL EA F() then
D TRANN( , ,  ), D TRANN( , ,  )
 ( )
 () ← max
={,}
else if CANA P PROX IMAT E(,  ) then
if I SL EA F() then
COM PU T EA P PROXNN (, ,  )
else
D TRANN( , ,  ),
D TRANN( , ,  )
 () ← max
={,}
end if
else if I SL EA F() then
D TRANN(,  ,  ), D TRANN(,  ,  )
else
D TRANN( ,  ,  ), D TRANN( ,  ,  )
D TRANN( ,  ,  ),
D TRANN( ,  ,  )
 () ← max
={,}
end if
end if
CANA P PROX IMAT E(,  )
return ⌈ ⋅ ∣∣⌉ ≤MAXSAM P L E S

 ( )

 ( )

Figure 2: Single tree (STRANKA P PROXNN) and dual tree (DTRANKA P PROXNN) algorithms and
subroutines for RANN search for a query  (or a query set  ) in a dataset  with rank approximation
 and success probability .  and  are the closer and farther child respectively of  from the
query  (or a query node )

Different datasets drawn for the UCI repository (Bio dataset 300k×74, Corel dataset 40k×32,
Covertype dataset 600k×55, Phy dataset 150k×78)[21], MN I S T handwritten digit recognition
dataset (60k×784)[22] and the Isomap “images ” dataset (700 ×4096)[3] are used. The ﬁnal dataset
“urand” is a synthetic dataset of points uniform randomly sa mpled from a unit ball (1m×20). This
dataset is used to show that even in the absence of a lower-dimensional subspace, RANN is able to
get signi ﬁcant speedups over exact methods for relatively l ow errors. For each dataset, the NN of
every point in the dataset is found in the exact case, and (1 + ⌈ ⋅  ⌉)-rank-approximate NN of every
point in the dataset is found in the approximate case. These results are summarized in Fig.3.

The results show that for even low values of  (high accuracy setting), the RANN algorithm is
signi ﬁcantly more scalable than the exact algorithms for al
l the datasets. Note that for some of the
datasets, the low values of approximation used in the experiments are equivalent to zero rank error
(which is the exact case), hence are equally efﬁcient as the e xact algorithm.

6

ε=0%(exact),0.001%,0.01%,0.1%,1%,10%
α=0.95

h
c
r
a
e
s
 
r
a
e
n
i
l
 
r
e
v
o
 
p
u
d
e
e
p
s

104

103

102

101

100

bio

corel

covtype images mnist

phy

urand

Figure 3: Speedups(logscale on the Y-axis) over the linear search algorithm while ﬁnd-
ing the NN in the exact case or (1 +  )-RANN in the approximate case with  =
0.001%, 0.01%, 0.1%, 1.0%, 10.0% and a ﬁxed success probability  = 0.95 for every point in
the dataset. The ﬁrst(white) bar in each dataset in the X-axi s is the speedup of exact dual tree
NN algorithm, and the subsequent(dark) bars are the speedups of the approximate algorithm with
increasing approximation.

4.2 Comparison with Distance-Approximate Search

In the case of the different forms of approximation, the average rank errors and the maximum rank
errors achieved in comparable retrieval times are considered for comparison. The rank errors are
compared since any method with relatively lower rank error will obviously have relatively lower
distance error. For DANN, Locality Sensitive Hashing (LSH) [19, 18] is used.

Subsets of two datasets known to have a lower-dimensional embedding are used for this experiment
- Layout Histogram (10k×30)[21] and MN I S T dataset (10k×784)[22]. The approximate NN of
every point in the dataset is found with different levels of approximation for both the algorithms.
The average rank error and maximum rank error is computed for each of the approximation levels.
For our algorithm, we increased the rank error and observed a corresponding decrease in the retrieval
time. LSH has three parameters. To obtain the best retrieval times with low rank error, we ﬁxed one
parameter and changed the other two to obtain a decrease in runtime and did this for many values of
the ﬁrst parameter. The results are summarized in Fig. 4 and F ig. 5.

The results show that even in the presence of a lower-dimensional embedding of the data, the rank
errors for a given retrieval time are comparable in both the approximate algorithms. The advantage
of the rank-approximate algorithm is that the rank error can be directly controlled, whereas in LSH,
tweaking in the cross-product of its three parameters is typically required to obtain the best ranks for
a particular retrieval time. Another advantage of the tree-based algorithm for RANN is the fact that
even though the maximum error is bounded only with a probability, the actual maximum error is not
much worse than the allowed maximum rank error since a tree is used. In the case of LSH, at times,
the actual maximum rank error is extremely large, corresponding to LSH returning points which
are very far from being the NN. This makes the proposed algorithm for RANN much more stable

7

Random Sample of size 10000

RANN
LSH

500

1000
1500
Average Rank Error

2000

(a) Layout Histogram

)
.
c
e
s
 
n
i
(
 
e
m
i
T

10

9

8

7

6

5

4

3

2

1

0

Random Sample of size 10000

RANN
LSH

0

500

1000

1500
2500
2000
Average Rank Error

3000

3500

4000

(b) Mnist

Figure 4: Query times on the X-axis and the Average Rank Error on the Y-axis.

Random Sample of size 10000

Random Sample of size 10000

RANN
LSH

)
.
c
e
s
 
n
i
(
 
e
m
i
T

10

9

8

7

6

5

4

3

2

1

0

RANN
LSH

0

1000

2000

3000
7000
6000
5000
4000
Maximum Rank Error

8000

9000 10000

)
.
c
e
s
 
n
i
(
 
e
m
i
T

4

3.5

3

2.5

2

1.5

1

0.5

0

0

4

3.5

3

2.5

2

1.5

1

0.5

)
.
c
e
s
 
n
i
(
 
e
m
i
T

0

0

1000

2000

3000
7000
6000
5000
4000
Maximum Rank Error

8000

9000 10000

(a) Layout Histogram

(b) Mnist

Figure 5: Query times on the X-axis and the Maximum Rank Error on the Y-axis.

than LSH for Euclidean NN search. Of course, the reported times highly depend on implementation
details and optimization tricks, and should be considered carefully.

5 Conclusion

We have proposed a new form of approximate algorithm for unscalable NN search instances by con-
trolling the true error of NN search (i.e. the ranks). This allows approximate NN search to retain
meaning in high dimensional datasets even in the absence of a lower-dimensional embedding. The
proposed algorithm for approximate Euclidean NN has been shown to scale much better than the
exact algorithm even for low levels of approximation even when the true dimension of the data is
relatively high. When compared with the popular DANN method (LSH), it is shown to be compara-
bly efﬁcient in terms of the average rank error even in the pre sence of a lower dimensional subspace
of the data (a fact which is crucial for the performance of the distance-approximate method). More-
over, the use of spatial-partitioning tree in the algorithm provides stability to the method by clamping
the actual maximum error to be within a reasonable rank threshold unlike the distance-approximate
method.

However, note that the proposed algorithm still beneﬁts fro m the ability of the underlying tree data
structure to bound distances. Therefore, our method is still not necessarily immune to the curse of
dimensionality. Regardless, RANN provides a new paradigm for NN search which is comparably
efﬁcient to the existing methods of distance-approximatio n and allows the user to directly control
the true accuracy which is present in ordering of the neighbors.

8

References

[1] T. Hastie, R. Tibshirani, and J. H. Friedman. The Elements of Statistical Learning: Data
Mining, Inference, and Prediction. Springer, 2001.
[2] B. W. Silverman. Density Estimation for Statistics and Data Analysis. Chapman & Hall/CRC,
1986.
[3] J. B. Tenenbaum, V. Silva, and J.C. Langford. A Global Geometric Framework for Nonlinear
Dimensionality Reduction. Science, 290(5500):2319–2323, 2000.
[4] S. T. Roweis and L. K. Saul. Nonlinear Dimensionality Reduction by Locally Linear Embed-
ding. Science, 290(5500):2323–2326, December 2000.
[5] A. N. Papadopoulos and Y. Manolopoulos. Nearest Neighbor Search: A Database Perspective.
Springer, 2005.
[6] N. Alon, M. B ˘adoiu, E. D. Demaine, M. Farach-Colton, and M. T. Hajiaghayi. Ordinal Em-
beddings of Minimum Relaxation: General Properties, Trees, and Ultrametrics. 2008.
[7] K. Beyer, J. Goldstein, R. Ramakrishnan, and U. Shaft. When Is “Nearest Neighbor ” Mean-
ingful? LECTURE NOTES IN COMPUTER SCIENCE, pages 217–235, 1999.
[8] J. M. Hammersley. The Distribution of Distance in a Hypersphere. Annals of Mathematical
Statistics, 21:447–452, 1950.
[9] J. H. Freidman, J. L. Bentley, and R. A. Finkel. An Algorithm for Finding Best Matches in
Logarithmic Expected Time. ACM Trans. Math. Softw., 3(3):209–226, September 1977.
[10] S. M. Omohundro. Five Balltree Construction Algorithms. Technical Report TR-89-063,
International Computer Science Institute, December 1989.
[11] F. P. Preparata and M. I. Shamos. Computational Geometry: An Introduction. Springer, 1985.
[12] A. Beygelzimer, S. Kakade, and J.C. Langford. Cover Trees for Nearest Neighbor. Proceedings
of the 23rd international conference on Machine learning, pages 97–104, 2006.
[13] A. G. Gray and A. W. Moore. ‘ -Body’ Problems in Statistical Learning. In NIPS, volume 4,
pages 521–527, 2000.
[14] T. Liu, A. W. Moore, A. G. Gray, and K. Yang. An Investigation of Practical Approximate
Nearest Neighbor Algorithms.
In Advances in Neural Information Processing Systems 17,
pages 825–832, 2005.
[15] L. Cayton. Fast Nearest Neighbor Retrieval for Bregman Divergences. Proceedings of the 25th
international conference on Machine learning, pages 112–119, 2008.
[16] T. Liu, A. W. Moore, and A. G. Gray. Efﬁcient Exact k-NN an d Nonparametric Classi ﬁcation
in High Dimensions. 2004.
[17] P. Ciaccia and M. Patella. PAC Nearest Neighbor Queries: Approximate and Controlled Search
in High-dimensional and Metric spaces. Data Engineering, 2000. Proceedings. 16th Interna-
tional Conference on, pages 244–255, 2000.
[18] A. Gionis, P. Indyk, and R. Motwani. Similarity Search in High Dimensions via Hashing.
pages 518–529, 1999.
[19] P. Indyk and R. Motwani. Approximate Nearest Neighbors: Towards Removing the Curse of
Dimensionality. In STOC, pages 604–613, 1998.
[20] J. Sedransk and J. Meyer. Conﬁdence Intervals for the Qu antiles of a Finite Population: Simple
Random and Strati ﬁed Simple Random sampling.
Journal of the Royal Statistical Society,
pages 239–252, 1978.
[21] C. L. Blake and C. J. Merz. UCI Machine Learning Repository. http://archive.ics.uci.edu/ml/,
1998.
[22] Y. LeCun. MN I S T dataset, 2000. http://yann.lecun.com/exdb/mnist/.

9

