A Parameter-free Hedging Algorithm

Kamalika Chaudhuri
ITA, UC San Diego
kamalika@soe.ucsd.edu

Yoav Freund
CSE, UC San Diego
yfreund@ucsd.edu

Daniel Hsu
CSE, UC San Diego
djhsu@cs.ucsd.edu

Abstract

We study the problem of decision-theoretic online learning (DTOL). Motivated
by practical applications, we focus on DTOL when the number of actions is very
large. Previous algorithms for learning in this framework have a tunable learning
rate parameter, and a barrier to using online-learning in practical applications is
that it is not understood how to set this parameter optimally, particularly when the
number of actions is large.
In this paper, we offer a clean solution by proposing a novel and completely
parameter-free algorithm for DTOL. We introduce a new notion of regret, which
is more natural for applications with a large number of actions. We show that our
algorithm achieves good performance with respect to this new notion of regret; in
addition, it also achieves performance close to that of the best bounds achieved
by previous algorithms with optimally-tuned parameters, according to previous
notions of regret.

1

Introduction

In this paper, we consider the problem of decision-theoretic online learning (DTOL), proposed by
Freund and Schapire [1]. DTOL is a variant of the problem of prediction with expert advice [2, 3].
In this problem, a learner must assign probabilities to a ﬁxe d set of actions in a sequence of rounds.
After each assignment, each action incurs a loss (a value in [0, 1]); the learner incurs a loss equal
to the expected loss of actions for that round, where the expectation is computed according to the
learner’s current probability assignment. The regret (of the learner) to an action is the difference
between the learner’s cumulative loss and the cumulative loss of that action. The goal of the learner
is to achieve, on any sequence of losses, low regret to the action with the lowest cumulative loss (the
best action).

DTOL is a general framework that captures many learning problems of interest. For example, con-
sider tracking the hidden state of an object in a continuous state space from noisy observations [4].
To look at tracking in a DTOL framework, we set each action to be a path (sequence of states) over
the state space. The loss of an action at time t is the distance between the observation at time t and
the state of the action at time t, and the goal of the learner is to predict a path which has loss close
to that of the action with the lowest cumulative loss.

The most popular solution to the DTOL problem is the Hedge algorithm [1, 5]. In Hedge, each action
is assigned a probability, which depends on the cumulative loss of this action and a parameter η , also
called the learning rate. By appropriately setting the learning rate as a function of the iteration [6, 7]
and the number of actions, Hedge can achieve a regret upper-bounded by O(√T ln N ), for each
iteration T , where N is the number of actions. This bound on the regret is optimal as there is a
Ω(√T ln N ) lower-bound [5].
In this paper, motivated by practical applications such as tracking, we consider DTOL in the regime
where the number of actions N is very large. A major barrier to using online-learning for practical
problems is that when N is large, it is not understood how to set the learning rate η . [7, 6] suggest

1

s
s
o
l
 
l
a
t
o
T

ε
Actions

Figure 1: A new notion of regret. Suppose each action is a point on a line, and the total losses are
as given in the plot. The regret to the top ǫ-quantile is the difference between the learner’s total loss
and the total loss of the worst action in the indicated interval of measure ǫ.

setting η as a ﬁxed function of the number of actions N . However, this can lead to poor performance,
as we illustrate by an example in Section 3, and the degradation in performance is particularly
exacerbated as N grows larger. One way to address this is by simultaneously running multiple
copies of Hedge with multiple values of the learning rate, and choosing the output of the copy
that performs the best in an online way. However, this solution is impractical for real applications,
particularly as N is already very large. (For more details about these solutions, please see Section 4.)
In this paper, we take a step towards making online learning more practical by proposing a novel,
completely adaptive algorithm for DTOL. Our algorithm is called NormalHedge. NormalHedge
is very simple and easy to implement, and in each round, it simply involves a single line search,
followed by an updating of weights for all actions.

A second issue with using online-learning in problems such as tracking, where N is very large, is
that the regret to the best action is not an effective measure of performance. For problems such as
tracking, one expects to have a lot of actions that are close to the action with the lowest loss. As
these actions also have low loss, measuring performance with respect to a small group of actions
that perform well is extremely reasonable – see, for example , Figure 1.

In this paper, we address this issue by introducing a new notion of regret, which is more natural
for practical applications. We order the cumulative losses of all actions from lowest to highest and
deﬁne the regret of the learner to the top ǫ-quantile to be the difference between the cumulative loss
of the learner and the ⌊ǫN ⌋-th element in the sorted list.
We prove that for NormalHedge, the regret to the top ǫ-quantile of actions is at most
O  rT ln
+ ln2 N ! ,
which holds simultaneously for all T and ǫ. If we set ǫ = 1/N , we get that the regret to the best
action is upper-bounded by O (cid:16)√T ln N + ln2 N (cid:17), which is only slightly worse than the bound
achieved by Hedge with optimally-tuned parameters. Notice that in our regret bound, the term
involving T has no dependence on N . In contrast, Hedge cannot achieve a regret-bound of this
nature uniformly for all ǫ. (For details on how Hedge can be modi ﬁed to perform with our n ew
notion of regret, see Section 4).

1
ǫ

NormalHedge works by assigning each action i a potential; actions which have lower cumulative
i,t /2ct ), where Ri,t is the regret of action
loss than the algorithm are assigned a potential exp(R2
i and ct is an adaptive scale parameter, which is adjusted from one round to the next, depending
on the loss-sequences. Actions which have higher cumulative loss than the algorithm are assigned
potential 1. The weight assigned to an action in each round is then proportional to the derivative of its
potential. One can also interpret Hedge as a potential-based algorithm, and under this interpretation,
the potential assigned by Hedge to action i is proportional to exp(ηRi,t ). This potential used by
Hedge differs signi ﬁcantly from the one we use. Although oth er potential-based methods have been
considered in the context of online learning [8], our potential function is very novel, and to the best

2

Initially: Set Ri,0 = 0, pi,1 = 1/N for each i.
For t = 1, 2, . . .
1. Each action i incurs loss ℓi,t .
2. Learner incurs loss ℓA,t = PN
i=1 pi,t ℓi,t .
3. Update cumulative regrets: Ri,t = Ri,t−1 + (ℓA,t − ℓi,t ) for each i.
(cid:17) = e.
i=1 exp (cid:16) ([Ri,t ]+ )2
N PN
4. Find ct > 0 satisfying 1
2ct
exp (cid:16) ([Ri,t ]+ )2
5. Update distribution for round t + 1: pi,t+1 ∝ [Ri,t ]+
2ct
ct
Figure 2: The Normal-Hedge algorithm.

(cid:17) for each i.

of our knowledge, has not been studied in prior work. Our proof techniques are also different from
previous potential-based methods.

Another useful property of NormalHedge, which Hedge does not possess, is that it assigns zero
weight to any action whose cumulative loss is larger than the cumulative loss of the algorithm it-
self. In other words, non-zero weights are assigned only to actions which perform better than the
algorithm. In most applications, we expect a small set of the actions to perform signi ﬁcantly better
than most of the actions. The regret of the algorithm is guaranteed to be small, which means that the
algorithm will perform better than most of the actions and thus assign them zero probability.

[9, 10] have proposed more recent solutions to DTOL in which the regret of Hedge to the best action
is upper bounded by a function of L, the loss of the best action, or by a function of the variations in
the losses. These bounds can be sharper than the bounds with respect to T . Our analysis (and in fact,
to our knowledge, any analysis based on potential functions in the style of [11, 8]) do not directly
yield these kinds of bounds. We therefore leave open the question of ﬁnding an adaptive algorithm
for DTOL which has regret upper-bounded by a function that depends on the loss of the best action.

The rest of the paper is organized as follows. In Section 2, we provide NormalHedge. In Section
3, we provide an example that illustrates the suboptimality of standard online learning algorithms,
when the parameter is not set properly. In Section 4, we discuss Related Work. In Section 5, we
present some outlines of the proof. The proof details are in the Supplementary Materials.

2 Algorithm

2.1 Setting

We consider the decision-theoretic framework for online learning. In this setting, the learner is given
access to a set of N actions, where N ≥ 2. In round t, the learner chooses a weight distribution
pt = (p1,t , . . . , pN ,t ) over the actions 1, 2, . . . , N . Each action i incurs a loss ℓi,t , and the learner
incurs the expected loss under this distribution:

N
Xi=1
The learner’s instantaneous regret to an action i in round t is ri,t = ℓA,t − ℓi,t , and its (cumulative)
t rounds is
regret to an action i in the ﬁrst

pi,t ℓi,t .

ℓA,t =

t
Xτ =1
We assume that the losses ℓi,t lie in an interval of length 1 (e.g. [0, 1] or [−1/2, 1/2]; the sign of the
loss does not matter). The goal of the learner is to minimize this cumulative regret Ri,t to any action
i (in particular, the best action), for any value of t.

Ri,t =

ri,τ .

3

2.2 Normal-Hedge

Our algorithm, Normal-Hedge, is based on a potential function reminiscent of the half-normal dis-
tribution, speci ﬁcally

φ(x, c) = exp (cid:18) ([x]+ )2
2c (cid:19) for x ∈ R, c > 0
where [x]+ denotes max{0, x}. It is easy to check that this function is separately convex in x and c,
differentiable, and twice-differentiable except at x = 0.
In addition to tracking the cumulative regrets Ri,t to each action i after each round t, the algorithm
also maintains a scale parameter ct . This is chosen so that the average of the potential, over all
actions i, evaluated at Ri,t and ct , remains constant at e:
N
exp (cid:18) ([Ri,t ]+ )2
(cid:19) = e.
Xi=1
2ct
We observe that since φ(x, c) is convex in c > 0, we can determine ct with a line search.
The weight assigned to i in round t is set proportional to the ﬁrst-derivative of the potential
at Ri,t−1 and ct−1 :
exp (cid:18) ([Ri,t−1 ]+ )2
φ(x, c)(cid:12)(cid:12)(cid:12)(cid:12)x=Ri,t−1 ,c=ct−1
[Ri,t−1 ]+
2ct−1
ct−1
Notice that the actions for which Ri,t−1 ≤ 0 receive zero weight in round t.
We summarize the learning algorithm in Figure 2.

pi,t ∝

, evaluated

(1)

(2)

1
N

∂
∂x

=

(cid:19) .

3 An Illustrative Example

In this section, we present an example to illustrate that setting the parameters of DTOL algorithms
as a function of N , the total number of actions, is suboptimal. To do this, we compare the perfor-
mance of NormalHedge with two representative algorithms: a version of Hedge due to [7], and the
Polynomial Weights algorithm, due to [12, 11]. Our experiments with this example indicate that the
performance of both these algorithms suffer because of the suboptimal setting of the parameters; on
the other hand, NormalHedge automatically adapts to the loss-sequences of the actions.

The main feature of our example is that the effective number of actions n (i.e. the number of distinct
actions) is smaller than the total number of actions N . Notice that without prior knowledge of the
actions and their loss-sequences, one cannot determine the effective number actions in advance; as a
result, there is no direct method by which Hedge and Polynomial Weights could set their parameters
as a function of n.
Our example attempts to model a practical scenario where one often ﬁnds multiple actions with
loss-sequences which are almost identical. For example, in the tracking problem, groups of paths
which are very close together in the state space, will have very close loss-sequences. Our example
indicates that in this case, the performance of Hedge and the Polynomial Weights will depend on
the discretization of the state space, however, NormalHedge will comparatively unaffected by such
discretization.

Our example has four parameters: N , the total number of actions; n, the effective number of actions
(the number of distinct actions); k , the (effective) number of good actions; and ǫ, which indicates
how much better the good actions are compared to the rest. Finally, T is the number of rounds.
The instantaneous losses of the N actions are represented by a N × T matrix B ε,k
N ; the loss of
action i in round t is the (i, t)-th entry in the matrix. The construction of the matrix is as follows.
First, we construct a (preliminary) n × T matrix An based on the 2d × 2d Hadamard matrix, where
n = 2d+1 − 2. This matrix An is obtained from the 2d × 2d Hadamard matrix by (1) deleting
the constant row, (2) stacking the remaining rows on top of their negations, (3) repeating each row

4

A6 =

Aε,2
6 =

horizontally T /2d times, and ﬁnally, (4) halving the ﬁrst column. We show A6 for concreteness:


−1/2 +1 −1 +1 −1 +1 −1 +1 −1 +1 −1 +1 . . .
−1/2 −1 +1 +1 −1 −1 +1 +1 −1 −1 +1 +1 . . .


−1/2 +1 +1 −1 −1 +1 +1 −1 −1 +1 +1 −1 . . .
+1/2 −1 +1 −1 +1 −1 +1 −1 +1 −1 +1 −1 . . .
+1/2 +1 −1 −1 +1 +1 −1 −1 +1 +1 −1 −1 . . .
+1/2 −1 −1 +1 +1 −1 −1 +1 +1 −1 −1 +1 . . .
If the rows of An give the losses for n actions over time, then it is clear that on average, no action
is better than any other. Therefore for large enough T , for these losses, a typical algorithm will
eventually assign all actions the same weight. Now, let Aε,k
n be the same as An except that ε is
subtracted from each entry of the ﬁrst k rows, e.g.


−1/2 − ε +1 − ε −1 − ε +1 − ε −1 − ε +1 − ε −1 − ε +1 − ε
−1/2 − ε −1 − ε +1 − ε +1 − ε −1 − ε −1 − ε +1 − ε +1 − ε


−1/2
+1
+1
−1
−1
+1
+1
−1
+1
−1
+1
−1
+1/2
−1
+1
−1
−1
−1
+1
+1
−1
−1
+1/2
+1
−1
−1
+1/2
+1
−1
+1
+1
−1
n , the ﬁrst k actions (the good actions) perform better than the
Now, when losses are given by Aε,k
remaining n − k ; so, for large enough T , a typical algorithm will eventually recognize this and
assign the ﬁrst k actions equal weights (giving little or no weight to the remaining n − k). Finally,
we arti ﬁcially replicate each action (each row) N/n times to yield the ﬁnal loss matrix B ε,k
N for N
actions:


N = 


B ε,k

The replication of actions signi ﬁcantly affects the behavi or of algorithms that set parameters with
respect to the number of actions N , which is inﬂated compared to the effective number of action s n.
NormalHedge, having no such parameters, is completely unaffected by the replication of actions.

N/n replicates of Aε,k
n .

Aε,k
n
Aε,k
n
...
Aε,k
n

. . .
. . .
. . .
. . .
. . .
. . .

.

We compare the performance of NormalHedge to two other representative algorithms, which we
call “Exp” and “Poly”. Exp is a time/variation-adaptive ver
sion of Hedge (exponential weights)
due to [7] (roughly, ηt = O(p(log N )/Vart ), where Vart is the cumulative loss variance). Poly
is polynomial weights [12, 11], which has a parameter p that is typically set as a function of the
number of actions; we set p = 2 ln N as is recommended to guarantee a regret bound comparable to
that of Hedge.

Figure 3 shows the regrets to the best action versus the replication factor N/n, where the effective
number of actions n is held ﬁxed. Recall that Exp and Poly have parameters set wit h respect to the
number of actions N .
We see from the ﬁgures that NormalHedge is completely unaffe cted by the replication of actions;
no matter how many times the actions may be replicated, the performance of NormalHedge stays
exactly the same. In contrast, increasing the replication factor affects the performance of Exp and
Poly: Exp and Poly become more sensitive to the changes in the total losses of the actions (e.g. the
base of the exponent in the weights assigned by Exp increases with N ); so when there are multiple
good actions (i.e. k > 1), Exp and Poly are slower to stabilize their weights over these good actions.
When k = 1, Exp and Poly actually perform better using the inﬂated valu e N (as opposed to n), as
this causes the slight advantage of the single best action to be magni ﬁed. However, this particular
case is an anomaly; this does not happen even for k = 2. We note that if the parameters of Exp
and Poly were set to be a function of n, instead of N , then, then their performance would also
not depend on the replication factor (the peformance would be the same as the N/n = 1 case).
Therefore, the degradation in performance of Exp and Poly is solely due to the suboptimality in
setting their parameters.

5

8
6
7
2
3
=
T
 
r
e
t
f
a
 
n
o
i
t
c
a
 
t
s
e
b
 
o
t
 
t
e
r
g
e
R

8
6
7
2
3
=
T
 
r
e
t
f
a
 
t
r
e
p
x
e
 
t
s
e
b
 
o
t
 
t
e
r
g
e
R

400

350

300

250

200

150

100
 
100

900

800

700

600

500

400
 
100

 

103

 

Exp.
Poly.
Normal

Exp.
Poly.
Normal

101

102

Replication factor
k = 1

101

102

103

Replication factor
k = 8

Exp.
Poly.
Normal

Exp.
Poly.
Normal

8
6
7
2
3
=
T
 
r
e
t
f
a
 
n
o
i
t
c
a
 
t
s
e
b
 
o
t
 
t
e
r
g
e
R

8
6
7
2
3
=
T
 
r
e
t
f
a
 
n
o
i
t
c
a
 
t
s
e
b
 
o
t
 
t
e
r
g
e
R

650

600

550

500

450

400
 
100

900

800

700

600

500

400
 
100

 

103

 

101

102

Replication factor
k = 2

101

102

103

Replication factor
k = 32

Figure 3: Regrets to the best action after T = 32768 rounds, versus replication factor N/n. Recall,
k is the (effective) number of good actions. Here, we ﬁx n = 126 and ǫ = 0.025.

4 Related work

There has been a large amount of literature on various aspects of DTOL. The Hedge algorithm of
[1] belongs to a more general family of algorithms, called the exponential weights algorithms; these
are originally based on Littlestone and Warmuth’s Weighted Majority algorithm [2], and they have
been well-studied.

The standard measure of regret in most of these works is the regret to the best action. The original
Hedge algorithm has a regret bound of O(√T log N ). Hedge uses a ﬁxed learning rate η for all
iterations, and requires one to set η as a function of the total number of iterations T . As a result,
its regret bound also holds only for a ﬁxed T . The algorithm of [13] guarantees a regret bound
of O(√T log N ) to the best action uniformly for all T by using a doubling trick. Time-varying
learning rates for exponential weights algorithms were considered in [6]; there, they show that if
ηt = p8 ln(N )/t, then using exponential weights with η = ηt in round t guarantees regret bounds
of √2T ln N + O(ln N ) for any T . This bound provides a better regret to the best action than we
do. However, this method is still susceptible to poor performance, as illustrated in the example in
Section 3. Moreover, they do not consider our notion of regret.

Though not explicitly considered in previous works, the exponential weights algorithms can be
partly analyzed with respect to the regret to the top ǫ-quantile. For any ﬁxed ǫ, Hedge can be
modi ﬁed by setting η as a function of this ǫ such that the regret to the top ǫ-quantile is at most
O(pT log(1/ǫ)). The problem with this solution is that it requires that the learning rate to be
set as a function of that particular ǫ (roughly η = p(log 1/ǫ)/T ). Therefore, unlike our bound,
this bound does not hold uniformly for all ǫ. One way to ensure a bound for all ǫ uniformly is to
run log N copies of Hedge, each with a learning rate set as a function of a different value of ǫ. A
ﬁnal master copy of the Hedge algorithm then looks at the prob abilities given by these subordinate
copiesto give the ﬁnal probabilities. However, this proced ure adds an additive O(√T log log N )
factor to the regret to the ǫ quantile of actions, for any ǫ. More importantly, this procedure is also
impractical for real applications, where one might be already working with a large set of actions.
In contrast, our solution NormalHedge is clean and simple, and we guarantee a regret bound for all
values of ǫ uniformly, without any extra overhead.

6

More recent work in [14, 7, 10] provide algorithms with signi ﬁcantly improved bounds when the
total loss of the best action is small, or when the total variation in the losses is small. These bounds
do not explicitly depend on T , and thus can often be sharper than ones that do (including ours). We
stress, however, that these methods use a different notion of regret, and their learning rates depend
explicitly on N .
Besides exponential weights, another important class of online learning algorithms are the poly-
nomial weights algorithms studied in [12, 11, 8]. These algorithms too require a parameter; this
parameter does not depend on the number of rounds T , but depends crucially on the number of ac-
tions N . The weight assigned to action i in round t is proportional to ([Ri,t−1 ]+ )p−1 for some p > 1;
setting p = 2 ln N yields regret bounds of the form p2eT (ln N − 0.5) for any T . Our algorithm
and polynomial weights share the feature that zero weight is given to actions that are performing
worse than the algorithm, although the degree of this weight sparsity is tied to the performance of
the algorithm. Finally, [15] derive a time-adaptive variation of the follow-the-(perturbed) leader
algorithm [16, 17] by scaling the perturbations by a parameter that depends on both t and N .

5 Analysis

5.1 Main results

(

(

16 ln2 N
δ

Our main result is the following theorem.
Theorem 1. If Normal-Hedge has access to N actions, then for all loss sequences, for all t, for all
0 < ǫ ≤ 1 and for all 0 < δ ≤ 1/2, the regret of the algorithm to the top ǫ-quantile of the actions is
at most
s(1 + ln(1/ǫ)) (cid:18)3(1 + 50δ)t +
16 ln2 N
δ2 + ln N )(cid:19) .
10.2
δ
In particular, with ǫ = 1/N , the regret to the best action is at most
s(1 + ln N ) (cid:18)3(1 + 50δ)t +
δ2 + ln N )(cid:19) .
10.2
The value δ in Theorem 1 appears to be an artifact of our analysis; we divide the sequence of rounds
into two phases – the length of the ﬁrst is controlled by the va
lue of δ – and bound the behavior of
the algorithm in each phase separately. The following corollary illustrates the performance of our
algorithm for large values of t, in which case the effect of this ﬁrst phase (and the δ in the bound)
essentially goes away.
Corollary 2. If Normal-Hedge has access to N actions, then, as t → ∞, the regret of Normal-
Hedge to the top ǫ-quantile of actions approaches an upper bound of
p3t(1 + ln(1/ǫ)) + o(t) .
In particular, the regret of Normal-Hedge to the best action approaches an upper bound of of
p3t(1 + ln N ) + o(t) .
The proof of Theorem 1 follows from a combination of Lemmas 3, 4, and 5, and is presented in
detail at the end of the current section.

5.2 Regret bounds from the potential equation

The following lemma relates the performance of the algorithm at time t to the scale ct .
Lemma 3. At any time t, the regret to the best action can be bounded as
Ri,t ≤ p2ct (ln N + 1) .
max
i
Moreover, for any 0 ≤ ǫ ≤ 1 and any t, the regret to the top ǫ-quantile of actions is at most
p2ct (ln(1/ǫ) + 1) .
7

Proof. We use Et to denote the actions that have non-zero weight on iteration t. The ﬁrst part of the
lemma follows from the fact that, for any action i ∈ Et ,
N
exp (cid:18) (Ri,t )2
2ct (cid:19) = exp (cid:18) ([Ri,t ]+ )2
(cid:19) ≤
Xi′=1
2ct
which implies Ri,t ≤ p2ct (ln N + 1).
For the second part of the lemma, let Ri,t denote the regret of our algorithm to the action with the
ǫN -th highest regret. Then, the total potential of the actions with regrets greater than or equal to
Ri,t is at least
ǫN exp (cid:18) ([Ri,t ]+ )2
(cid:19) ≤ N e
2ct
from which the second part of the lemma follows.

exp (cid:18) ([Ri′ ,t ]+ )2
2ct

(cid:19) ≤ N e

5.3 Bounds on the scale ct and the proof of Theorem 1

In Lemmas 4 and 5, we bound the growth of the scale ct as a function of the time t.
The main outline of the proof of Theorem 1 is as follows. As ct increases monotonically with t, we
can divide the rounds t into two phases, t < t0 and t ≥ t0 , where t0 is the ﬁrst time such that
4 ln2 N
16 ln N
ct0 ≥
δ3
δ
for some ﬁxed δ ∈ (0, 1/2). We then show bounds on the growth of ct for each phase separately.
Lemma 4 shows that ct is not too large at the end of the ﬁrst phase, while Lemma 5 boun ds the
per-round growth of ct in the second phase. The proofs of these two lemmas are quite involved, so
we defer them to the supplementary appendix.
Lemma 4. For any time t,

+

,

ct+1 ≤ 2ct (1 + ln N ) + 3 .

Lemma 5. Suppose that at some time t0 , ct0 ≥ 4 ln2 N
δ + 16 ln N
δ3
Then, for any time t ≥ t0 ,
3
2

ct+1 − ct ≤

(1 + 49.19δ) .

, where 0 ≤ δ ≤ 1
2 is a constant.

We now combine Lemmas 4 and 5 together with Lemma 3 to prove the main theorem.

Proof of Theorem 1. Let t0 be the ﬁrst time at which ct0 ≥ 4 ln2 N
δ + 16 ln N
δ3
ct0 ≤ 2ct0−1 (1 + ln N ) + 3,

which is at most

. Then, from Lemma 4,

+

.

+

8 ln3 N
81 ln2 N
34 ln2 N
8 ln3 N
32 ln N
δ3 + 3 ≤
δ3
δ3
δ
δ
The last inequality follows because N ≥ 2 and δ ≤ 1/2. By Lemma 5, we have that for any t ≥ t0 ,
3
ct ≤
(1 + 49.19δ)(t − t0 ) + ct0 .
2
Combining these last two inequalities yields

+

3
ct ≤
2
Now the theorem follows by applying Lemma 3.

(1 + 49.19δ)t +

8 ln3 N
δ

+

81 ln2 N
δ3

.

8

Tracking using explanation-based modeling, 2009.

References
[1] Y. Freund and R. E. Schapire. A decision-theoretic generalization of on-line learning and an application
to boosting. Journal of Computer and System Sciences, 55:119–139, 1997.
[2] N. Littlestone and M. Warmuth. The weighted majority algorithm.
Information and Computation,
108:212–261, 1994.
[3] V. Vovk. A game of prediction witih expert advice. Journal of Computer and System Sciences, 56(2):153–
173, 1998.
[4] K. Chaudhuri, Y. Freund, and D. Hsu.
arXiv:0903.2862.
[5] Y. Freund and R. E. Schapire. Adaptive game playing using multiplicative weights. Games and Economic
Behavior, 29:79–103, 1999.
[6] P. Auer, N. Cesa-Bianchi, and C. Gentile. Adaptive and self-conﬁ dent on-line learning algorithms. Journal
of Computer and System Sciences, 64(1), 2002.
[7] N. Cesa-Bianchi, Y. Mansour, and G. Stoltz. Improved second-order bounds for prediction with expert
advice. Machine Learning, 66(2–3):321–352, 2007.
[8] N. Cesa-Bianchi and G. Lugosi. Potential-based algorithms in on-line prediction and game theory. Ma-
chine Learning, 51:239–261, 2003.
[9] N. Cesa-Bianchi and G. Lugosi. Prediction, Learning and Games. Cambridge University Press, 2006.
[10] E. Hazan and S. Kale. Extracting certainty from uncertainty: Regret bounded by variation in costs. In
COLT, 2008.
[11] C. Gentile. The robustness of p-norm algorithms. Machine Learning, 53(3):265–299, 2003.
[12] A. J. Grove, N. Littlestone, and D. Schuurmans. General convergence results for linear discriminant
updates. Machine Learning, 43(3):173–210, 2001.
[13] N. Cesa-Bianchi, Y. Freund, D. Haussler, D. P. Hembold, R. E. Schapire, and M. Warmuth. How to use
expert advice. Journal of the ACM, 44(3):427–485, 1997.
[14] R. Yaroshinsky, R. El-Yaniv, , and S. Seiden. How to better use expert advice. Machine Learning,
55(3):271–309, 2004.
[15] M. Hutter and J. Poland. Adaptive online prediction by following the perturbed leader. Journal of Machine
Learning Research, 6:639–660, 2005.
[16] J. Hannan. Approximation to bayes risk in repeated play. Contributions to the Theory of Games, 3:97–
139, 1957.
[17] A. Kalai and S. Vempala. Efﬁcient algorithms for the online optimizatio n. Journal of Computer and
System Sciences, 71(3):291–307, 2005.

9

