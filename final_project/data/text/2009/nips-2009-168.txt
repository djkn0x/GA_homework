Exponential Family Graph Matching and Ranking

James Petterson, Tib ´erio S. Caetano, Julian J. McAuley and Jin Yu
NICTA, Australian National University
Canberra, Australia
Abstract
We present a method for learning max-weight matching predictors in bipartite
graphs. The method consists of performing maximum a posteriori estimation
in exponential families with sufﬁcient statistics that encode permutations and
data features. Although inference is in general hard, we show that for one very
relevant application–document ranking–exact inference is efﬁcient. For general
model instances, an appropriate sampler is readily available. Contrary to existing
max-margin matching models, our approach is statistically consistent and, in ad-
dition, experiments with increasing sample sizes indicate superior improvement
over such models. We apply the method to graph matching in computer vision as
well as to a standard benchmark dataset for learning document ranking, in which
we obtain state-of-the-art results, in particular improving on max-margin variants.
The drawback of this method with respect to max-margin alternatives is its run-
time for large graphs, which is comparatively high.

Introduction
1
The Maximum-Weight Bipartite Matching Problem (henceforth ‘matching problem’) is a funda-
mental problem in combinatorial optimization [22]. This is the problem of ﬁnding the ‘heaviest’
perfect match in a weighted bipartite graph. An exact optimal solution can be found in cubic time
by standard methods such as the Hungarian algorithm.
This problem is of practical interest because it can nicely model real-world applications. For ex-
ample, in computer vision the crucial problem of ﬁnding a correspondence between sets of image
features is often modeled as a matching problem [2, 4]. Ranking algorithms can be based on a
matching framework [13], as can clustering algorithms [8].
When modeling a problem as one of matching, one central question is the choice of the weight
matrix. The problem is that in real applications we typically observe edge feature vectors, not edge
weights. Consider a concrete example in computer vision: it is difﬁcult to tell what the ‘similar-
ity score’ is between two image feature points, but it is straightforward to extract feature vectors
(e.g. SIFT) associated with those points.
In this setting, it is natural to ask whether we could parameterize the features, and use labeled
matches in order to estimate the parameters such that, given graphs with ‘similar’ features, their
resulting max-weight matches are also ‘similar’. This idea of ‘parameterizing algorithms’ and then
optimizing for agreement with data is called structured estimation [27, 29].
[27] and [4] describe max-margin structured estimation formalisms for this problem. Max-margin
structured estimators are appealing in that they try to minimize the loss that one really cares about
(‘structured losses’, of which the Hamming loss is an example). However structured losses are typi-
cally piecewise constant in the parameters, which eliminates any hope of using smooth optimization
directly. Max-margin estimators instead minimize a surrogate loss which is easier to optimize,
namely a convex upper bound on the structured loss [29]. In practice the results are often good,
but known convex relaxations produce estimators which are statistically inconsistent [18], i.e., the
algorithm in general fails to obtain the best attainable model in the limit of inﬁnite training data. The
inconsistency of multiclass support vector machines is a well-known issue in the literature that has
received careful examination recently [16, 15].

1

Motivated by the inconsistency issues of max-margin structured estimators as well as by the well-
known beneﬁts of having a full probabilistic model, in this paper we present a maximum a posteriori
(MAP) estimator for the matching problem. The observed data are the edge feature vectors and
the labeled matches provided for training. We then maximize the conditional posterior probability
of matches given the observed data. We build an exponential family model where the sufﬁcient
statistics are such that the mode of the distribution (the prediction) is the solution of a max-weight
matching problem. The resulting partition function is (cid:93)P-complete to compute exactly. However,
we show that for learning to rank applications the model instance is tractable. We then compare
the performance of our model instance against a large number of state-of-the-art ranking methods,
including DORM [13], an approach that only differs from our model instance by using max-margin
instead of a MAP formulation. We show very competitive results on standard document ranking
datasets, and in particular we show that our model performs better than or on par with DORM. For
intractable model instances, we show that the problem can be approximately solved using sampling
and we provide experiments from the computer vision domain. However the fastest suitable sampler
is still quite slow for large models, in which case max-margin matching estimators like those of [4]
and [27] are likely to be preferable even in spite of their potential inferior accuracy.

2 Background
2.1 Structured Prediction
In recent years, great attention has been devoted in Machine Learning to so-called structured pre-
dictors, which are predictors of the kind

(1)

gθ : X (cid:55)→ Y,
where X is an arbitrary input space and Y is an arbitrary discrete space, typically exponentially
large. Y may be, for example, a space of matrices, trees, graphs, sequences, strings, matches, etc.
This structured nature of Y is what structured prediction refers to. In the setting of this paper, X is the
set of vector-weighted bipartite graphs (i.e., each edge has a feature vector associated with it), and
Y is the set of perfect matches induced by X. If N graphs are available, along with corresponding
annotated matches (i.e., a set {(xn , yn )}N
n=1 ), our task will be to estimate θ such that when we apply
the predictor gθ to a new graph it produces a match that is similar to matches of similar graphs from
the annotated set. Structured learning or structured estimation refers to the process of estimating a
vector θ for predictor gθ when data {(x1 , y1 ), . . . , (xN , yN )} ∈ (X × Y)N are available. Structured
prediction for input x means computing y = g(x; θ) using the estimated θ .
Two generic estimation strategies have been popular in producing structured predictors. One is based
on max-margin estimators [29, 27], and the other on maximum-likelihood (ML) or MAP estimators
in exponential family models [12].
The ﬁrst approach is a generalization of support vector machines to the case where the set Y is
structured. However the resulting estimators are known to be inconsistent in general: in the limit
of inﬁnite training data the algorithm fails to recover the best model in the model class [18, 16, 15].
McAllester recently provided an interesting analysis on this issue, where he proposed new upper
bounds whose minimization results in consistent estimators, but no such bounds are convex [18].
The other approach uses ML or MAP estimation in conditional exponential families with ‘struc-
tured’ sufﬁcient statistics, such as in probabilistic graphical models, where they are decomposed
over the cliques of the graph (in which case they are called Conditional Random Fields, or CRFs
[12]). In the case of tractable graphical models, dynamic programming can be used to efﬁciently
perform inference. ML and MAP estimators in exponential families not only amount to solving an
unconstrained and convex optimization problem; in addition they are statistically consistent. The
main problem with these types of models is that often the partition function is intractable. This has
motivated the use of max-margin methods in many scenarios where such intractability arises.

2.2 The Matching Problem
Consider a weighted bipartite graph with m nodes in each part, G = (V , E , w), where V is the set
of vertices, E is the set of edges and w : E (cid:55)→ R is a set of real-valued weights associated with
the edges. G can be simply represented by a matrix (wij ) where the entry wij is the weight of the
edge ij . Consider also a bijection y : {1, 2, . . . , m} (cid:55)→ {1, 2, . . . , m}, i.e., a permutation. Then the
matching problem consists of computing

2

Figure 1: Left: Illustration of an input vector-weighted bipartite graph Gx with 3 × 3 edges. There
is a vector xe associated with each edge e (for clarity only xij is shown, corresponding to the solid
edge). Right: weighted bipartite graph G obtained by evaluating Gx on the learned vector θ (again
only edge ij is shown).
m(cid:88)i=1
This is a well-studied problem; it is tractable and can be solved in O(m3 ) time [22]. This model can
be used to match features in images [4], improve classiﬁcation algorithms [8] and rank documents
[13], to cite a few applications. The typical setting consists of engineering the score matrix wij
according to domain knowledge and subsequently solving the combinatorial problem.

y∗ = argmax
y

wiy(i) .

(2)

3 The Model
3.1 Basic Goal
In this paper we assume that the weights wij are instead to be estimated from training data. More
precisely, the weight wij associated with the edge ij in a graph will be the result of an appropriate
composition of a feature vector xij (observed) and a parameter vector θ (estimated from training
data). Therefore, in practice, our input is a vector-weighted bipartite graph Gx = (V , E , x) (x :
E (cid:55)→ Rn ), which is ‘evaluated’ at a particular θ (obtained from previous training) so as to attain the
graph G = (V , E , w). See Figure 1 for an illustration. More formally, assume that a training set
{X, Y } = {(xn , yn )}N
n=1 is available, where xn := (xn
M (n)M (n) ). Here M (n) is the
11 , xn
12 . . . , xn
number of nodes in each part of the vector-weighted bipartite graph xn . We then parameterize xij
as wiy(i) = f (xiy(i) ; θ), and the goal is to ﬁnd the θ which maximizes the posterior probability of
the observed data. We will assume f to be bilinear, i.e., f (xiy(i) ; θ) = (cid:10)xiy(i) , θ(cid:11).
3.2 Exponential Family Model
We assume an exponential family model, where the probability model is
p(y |x; θ) = exp ((cid:104)φ(x, y), θ(cid:105) − g(x; θ)), where
g(x; θ) = log (cid:88)y
exp (cid:104)φ(x, y), θ(cid:105)
is the log-partition function, which is a convex and differentiable function of θ [31].
The prediction in this model is the most likely y , i.e.,
(cid:104)φ(x, y), θ(cid:105)
p(y |x; θ) = argmax
y∗ = argmax
y
y
and ML estimation amounts to maximizing the conditional likelihood of the training set {X, Y },
i.e., computing argmaxθ p(Y |X ; θ). In practice we will in general introduce a prior on θ and per-
form MAP estimation:

(5)

(3)

(4)

p(θ|Y , X ).
p(Y |X ; θ)p(θ) = argmax
θ∗ = argmax
θ
θ
Assuming iid sampling, we have p(Y |X ; θ) = (cid:81)N
n=1 p(yn |xn ; θ). Therefore,
p(θ|Y , X ) ∝ exp (cid:32)log p(θ) +
((cid:104)φ(xn , yn ), θ(cid:105) − g(xn ; θ))(cid:33).
N(cid:88)n=1
3

(6)

(7)

toattainthegraphG=(V,E,w).SeeFigure1foranillustration.GxGijijxijwij=hxij,θiFigure1.Left:Illustrationofaninputvector-weightedbi-partitegraphGxwith3×3edges.Thereisavectorxeassociatedtoeachedgee(forclarityonlyxijisshown,correspondingtothesolidedge).Right:weightedbipar-titegraphGobtainedbyevaluatingGxonthelearnedvectorθ(againonlyedgeijisshown).Moreformally,assumethatatrainingset{X,Y}={(x1,y1),...,(xN,yN)}isavailable,forn=1,2,...,N(wherexn:=(xn11,xn12...,xnM(n)M(n))).HereM(n)isthenumberofnodesineachpartofthevector-weightedbipartitegraphxn.Wethenparameterizexijaswiy(i)=f(xiy(i);θ),andthegoalistoﬁndtheθwhichmaximizestheposteriorlikelihoodoftheobserveddata.Wewillassumeftobebilinear,i.e.f(xiy(i);θ)=(cid:10)xiy(i),θ(cid:11).3.2.ExponentialFamilyModelWeassumeanexponentialfamilymodel,wheretheprobabilitymodelisp(y|x;θ)=exp(hφ(x,y),θi−g(x;θ)),(3)whereg(x;θ)=logXyexphφ(x,y),θi(4)isthelog-partitionfunction,whichisaconvexanddif-ferentiablefunctionofθ(Wainwright&Jordan,2003).Thepredictioninthismodelisthemostlikelyy,i.e.y∗=argmaxyp(y|x;θ)=argmaxyhφ(x,y),θi(5)andMLestimationamountstomaximizingthecon-ditionallikelihoodofasample{X,Y},i.e.computingargmaxθp(Y|X;θ).Inpracticewewillingeneralin-troduceaprioronθandperformMAPestimation:θ∗=argmaxθp(Y|X;θ)p(θ)=argmaxθp(θ|Y,X).(6)Assumingiidsampling,wehavep(Y|X;θ)=QNn=1p(yn|xn;θ).Therefore,p(θ|Y,X)∝p(θ)NYn=1exp(hφ(xn,yn),θi−g(xn;θ))=exp logp(θ)+NXn=1(hφ(xn,yn),θi−g(xn;θ))!.(7)WeimposeaGaussianprioronθ.Insteadofmaximiz-ingtheposteriorwecaninsteadminimizethenegativelog-posterior‘(Y|X;θ),whichbecomesourlossfunc-tion(wesuppresstheconstantterm):‘(Y|X;θ)=λ2kθk2+1NNXn=1(g(xn;θ)−hφ(xn,yn),θi)(8)whereλisaregularizationconstant.‘(Y|X;θ)isaconvexfunctionofθsincethelog-partitionfunctiong(θ)isaconvexfunctionofθ(Wainwright&Jordan,2003)andtheothertermsareclearlyconvexinθ.3.3.FeatureParameterizationThecriticalobservationnowisthatweequatetheso-lutionofthematchingproblem(2)tothepredictionoftheexponentialfamilymodel(5),i.e.Piwiy(i)=hφ(x,y),θi.Sinceourgoalistoparameterizefea-turesofindividualpairsofnodes(soastoproducetheweightofanedge),themostnaturalmodelisφ(x,y)=MXi=1xiy(i),whichgives(9)wiy(i)=(cid:10)xiy(i),θ(cid:11),(10)i.e.linearinbothxandθ(seeFigure1,right).Thespeciﬁcformforxijwillbediscussedintheexperi-mentalsection.Inlightof(10),(2)nowclearlymeansapredictionofthebestmatchforGxunderthemodelθ.4.LearningtheModel4.1.BasicsWeneedtosolveθ∗=argminθ‘(Y|X;θ).‘(Y|X;θ)isaconvexanddiﬀerentiablefunctionofθ(Wainwright&Jordan,2003),thereforegradientdescentwillﬁndtheglobaloptimum.Inordertocompute∇θ‘(Y|X;θ),weneedtocompute∇θg(θ).Itisastandardresultofexponentialfamiliesthatthegradientofthelog-partitionfunctionistheexpectationofthesuﬃcientstatistics:∇θg(x;θ)=Ey∼p(y|x;θ)[φ(x,y)].(11)We impose a Gaussian prior on θ . Instead of maximizing the posterior we can instead minimize the
negative log-posterior (cid:96)(Y |X ; θ), which becomes our loss function (we suppress the constant term):
N(cid:88)n=1
1
(cid:96)(Y |X ; θ) = λ
2 (cid:107)θ(cid:107)2 +
(g(xn ; θ) − (cid:104)φ(xn , yn ), θ(cid:105))
(8)
N
where λ is a regularization constant. (cid:96)(Y |X ; θ) is a convex function of θ since the log-partition
function g(θ) is a convex function of θ [31] and the other terms are clearly convex in θ .
3.3 Feature Parameterization
The critical observation now is that we equate the solution of the matching problem (2) to the pre-
diction of the exponential family model (5), i.e., (cid:80)i wiy(i) = (cid:104)φ(x, y), θ(cid:105). Since our goal is to
parameterize features of individual pairs of nodes (so as to produce the weight of an edge), the most
natural model is
M(cid:88)i=1
φ(x, y) =
(9)
xiy(i) , which gives
wiy(i) = (cid:10)xiy(i) , θ(cid:11) ,
(10)
i.e., linear in both x and θ (see Figure 1, right). The speciﬁc form for xij will be discussed in the
experimental section. In light of (10), (2) now clearly means a prediction of the best match for Gx
under the model θ .

4 Learning the Model
4.1 Basics
We need to solve θ∗ = argminθ (cid:96)(Y |X ; θ). (cid:96)(Y |X ; θ) is a convex and differentiable function of
θ [31], therefore gradient descent will ﬁnd the global optimum. In order to compute ∇θ (cid:96)(Y |X ; θ),
we need to compute ∇θ g(θ). It is a standard result of exponential families that the gradient of the
log-partition function is the expectation of the sufﬁcient statistics:
∇θ g(x; θ) = Ey∼p(y |x;θ) [φ(x, y)].
(11)
Therefore in order to perform gradient descent we need to compute the above expectation. Opening
the above expression gives
Ey∼p(y |x;θ) [φ(x, y)] = (cid:88)y
φ(x, y)p(y |x; θ)
M(cid:89)i=1
Z (x; θ) (cid:88)y
1
exp((cid:10)xiy(i) , θ(cid:11)),
=
φ(x, y)
which reveals that the partition function Z (x; θ) needs to be computed. The partition function is:
M(cid:89)i=1
Z (x; θ) = (cid:88)y
exp((cid:10)xiy(i) , θ(cid:11))
(cid:124)
(cid:123)(cid:122)
(cid:125)
=:Biy(i)
Note that the above is the expression for the permanent of matrix B [19]. The permanent is similar
in deﬁnition to the determinant, the difference being that for the latter sgn(y) comes before the
product. However, unlike the determinant, which is computable efﬁciently and exactly by standard
linear algebra manipulations, computing the permanent is a (cid:93)P-complete problem [30]. Therefore
we have no realistic hope of computing (11) exactly for general problems.

(13)

.

(12)

(14)

4.2 Exact Expectation

The exact partition function itself can be efﬁciently computed for up to about M = 30 using the
O(M 2M ) algorithm by Ryser [25]. However for arbitrary expectations we are not aware of any
exact algorithm which is more efﬁcient than full enumeration (which would constrain tractability
to very small graphs). However we will see that even in the case of very small graphs we ﬁnd a
very important application: learning to rank. In our experiments, we successfully apply a tractable
instance of our model to benchmark document ranking datasets, obtaining very competitive results.
For larger graphs, we have alternative options as indicated below.

4

4.3 Approximate Expectation
If we have a situation in which the set of feasible permutations is too large to be fully enumerated
efﬁciently, we need to resort to some approximation for the expectation of the sufﬁcient statistics.
The best solution we are aware of is one by Huber and Law, who recently presented an algorithm to
approximate the permanent of dense non-negative matrices [10]. The algorithm works by producing
exact samples from the distribution of perfect matches on weighted bipartite graphs. This is in
precisely the same form as the distribution we have here, p(y |x; θ) [10]. We can use this algorithm
for applications that involve larger graphs.We generate K samples from the distribution p(y |x; θ),
and directly approximate (12) with a Monte Carlo estimate
K(cid:88)i=1
Ey∼p(y |x;θ) [φ(x, y)] ≈
In our experiments, we apply this algorithm to an image matching application.

φ(x, yi ).

1
K

(15)

5 Experiments
5.1 Ranking
Here we apply the general matching model introduced in previous sections to the task of learning
to rank. Ranking is a fundamental problem with applications in diverse areas such as document
retrieval, recommender systems, product rating and others. Early learning to rank methods applied a
pairwise approach, where pairs of documents were used as instances in learning [7, 6, 3]. Recently
there has been interest in listwise approaches, where document lists are used as instances, as in our
method. In this paper we focus, without loss of generality, on document ranking.
We are given a set of queries {qk } and, for each query qk , a list of D(k) documents {dk
1 , . . . , dk
D(k) }
with corresponding ratings {rk
D(k)} (assigned by a human editor), measuring the relevance
1 , . . . , rk
degree of each document with respect to query qk . A rating or relevance degree is usually a nominal
value in the list {1, . . . , R}, where R is typically between 2 and 5. We are also given, for every
retrieved document dk
i , a joint feature vector ψk
i for that document and the query qk .
Training At training time, we model each query qk as a vector-weighted bipartite graph (Figure
1) where the nodes on one side correspond to a subset of cardinality M of all D(k) documents
retrieved by the query, and the nodes on the other side correspond to all possible ranking positions for
these documents (1, . . . , M ). The subset itself is chosen randomly, provided at least one exemplar
document of every rating is present. Therefore M must be such that M ≥ R.
The process is then repeated in a bootstrap manner: we resample (with replacement) from the set
of documents {dk
D(k)}, M documents at a time (conditioned on the fact that at least one
1 , . . . , dk
exemplar of every rating is present, but otherwise randomly). This effectively boosts the number of
training examples since each query qk ends up being selected many times, each time with a different
subset of M documents from the original set of D(k) documents.
In the following we drop the query index k to examine a single query. Here we follow the con-
struction used in [13] to map matching problems to ranking problems (indeed the only difference
between our ranking model and that of [13] is that they use a max-margin estimator and we use MAP
in an exponential family.) Our edge feature vector xij will be the product of the feature vector ψi
associated with document i, and a scalar cj (the choice of which will be explained below) associated
with ranking position j

xij = ψi cj .
(16)
ψi is dataset speciﬁc (see details below). From (10) and (16), we have wij = cj (cid:104)ψi , θ(cid:105), and training
proceeds as explained in Section 4.
Testing At test time, we are given a query q and its corresponding list of D associated documents.
We then have to solve the prediction problem, i.e.,
D(cid:88)i=1 (cid:10)xiy(i) , θ(cid:11) = argmax
y
5

y∗ = argmax
y

cy(i) (cid:104)ψi , θ(cid:105) .

D(cid:88)i=1

(17)

Figure 2: Results of NDCG@k for state-of-the-art methods on TD2004 (left), TD2003 (middle) and
OHSUMED (right). This is best viewed in color.

We now notice that if the scalar cj = c(j ), where c is a non-increasing function of rank position
j , then (17) can be solved simply by sorting the values of (cid:104)ψi , θ(cid:105) in decreasing order.1 In other
words, the matching problem becomes one of ranking the values (cid:104)ψi , θ(cid:105). Inference in our model is
therefore very fast (linear time).2 In this setting it makes sense to interpret the quantity (cid:104)ψi , θ(cid:105) as a
score of document di for query q . This leaves open the question of which non-increasing function c
should be used. We do not solve this problem in this paper, and instead choose a ﬁxed c. In theory
it is possible to optimize over c during learning, but in that case the optimization problem would no
longer be convex. We describe the results of our method on LETOR 2.0 [14], a publicly available
benchmark data collection for comparing learning to rank algorithms. It is comprised of three data
sets: OHSUMED, TD2003 and TD2004.
Data sets OHSUMED contains features extracted from query-document pairs in the OHSUMED
collection, a subset of MEDLINE, a database of medical publications. It contains 106 queries. For
each query there are a number of associated documents, with relevance degrees judged by humans
on three levels: deﬁnitely, possibly or not relevant. Each query-document pair is associated with a
25 dimensional feature vector, ψi . The total number of query-document pairs is 16,140. TD2003
and TD2004 contain features extracted from the topic distillation tasks of TREC 2003 and TREC
2004, with 50 and 75 queries, respectively. Again, for each query there are a number of associated
documents, with relevance degrees judged by humans, but in this case only two levels are provided:
relevant or not relevant. Each query-document pair is associated with a 44 dimensional feature
vector, ψi . The total number of query-document pairs is 49,171 for TD2003 and 74,170 for TD2004.
All datasets are already partitioned for 5-fold cross-validation. See [14] for more details.
Evaluation Metrics In order to measure the effectiveness of our method we use the normalized
discount cumulative gain (NDCG) measure [11] at rank position k , which is deﬁned as
k(cid:88)j=1
where r(j ) is the relevance of the j th document in the list, and Z is a normalization constant so that
a perfect ranking yields an NDCG score of 1.

2r(j ) − 1
log(1 + j ) ,

(18)

NDCG@k =

1
Z

π

1 If r(v) denotes the vector of ranks of entries of vector v , then (cid:104)a, π(b)(cid:105) is maximized by the permutation
∗ such that r(a) = r(π
∗
(b)), a theorem due to Polya, Littlewood, Hardy and Blackwell [26].
2Sorting the top k items of a list of D items takes O(k log k + D) time [17].

6

123456789100.350.40.450.50.550.60.65kNDCGTD2004  RankMatch (Our Method), M=2DORMRankBoostRankSVMFRankListNetAdaRank−MAPAdaRank−NDCGQBRankIsoRankSortNet 20 hiddens MAPSortNet 20 hiddens P@10StructRankC−CRF123456789100.20.250.30.350.40.450.50.55kNDCGTD2003  RankMatch (Our Method), M=2 (all)DORMRankBoostRankSVMFRankListNetAdaRank−MAPAdaRank−NDCGQBRankIsoRankSortNet 10 hiddens MAPSortNet 10 hiddens P@10123456789100.420.440.460.480.50.520.540.560.58kNDCGOHSUMED  RankMatch (Our Method), M=3DORMRankBoostRankSVMFRankListNetAdaRank−MAPAdaRank−NDCGQBRankIsoRankStructRankC−CRFTable 1: Training times (per observation, in seconds, Intel Core2 2.4GHz) for the exponential model
and max-margin. Runtimes for M = 3, 4, 5 are from the ranking experiments, computed by full
enumeration; M = 20 corresponds to the image matching experiments, which use the sampler from
[10]. A problem of size 20 cannot be practically solved by full enumeration.
M exponential model max margin
0.0008965
0.0006661
3
0.0016086
0.0011277
4
5
0.0030187
0.0015328
0.9334556
36.0300000
20
External Parameters The regularization constant λ is chosen by 5-fold cross-validation, with the
partition provided by the LETOR package. All experiments are repeated 5 times to account for the
randomness of the sampling of the training data. We use c(j ) = M − j on all experiments.
Optimization To optimize (8) we use a standard BFGS Quasi-Newton method with a backtracking
line search, as described in [21].
Results For the ﬁrst experiment training was done on subsets sampled as described above, where
for each query qk we sampled 0.4 · D(k) · M subsets, therefore increasing the number of samples
linearly with M . For TD2003 we also trained with all possible subsets (M = 2(all) in the plots).
In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those
achieved by a number of state-of-the-art methods which have published NDCG scores in at least two
of the datasets: RankBoost [6], RankSVM [7], FRank [28], ListNet [5], AdaRank [32], QBRank
[34], IsoRank [33], SortNet [24], StructRank [9] and C-CRF [23]. We also included a plot of our
implementation of DORM [13], using precisely the same resampling methodology and data for a
fair comparison. RankMatch performs among the best methods on both TD2004 and OHSUMED,
while on TD2003 it performs poorly (for low k) or fairly well (for high k).
We notice that there are four methods which only report results in two of the three datasets: the
two SortNet versions are only reported on TD2003 and TD2004, while StructRank and C-CRF
are only reported on TD2004 and OHSUMED. RankMatch compares similarly with SortNet and
StructRank on TD2004, similarly to C-CRF and StructRank on OHSUMED and similarly to the
two versions of SortNet on TD2003. This exhausts all the comparisons against the methods which
have results reported in only two datasets. A fairer comparison could be made if these methods had
their performance published for the respective missing dataset.
When compared to the methods which report results in all datasets, RankMatch entirely dominates
their performance on TD2004 and is second only to IsoRank on OHSUMED.
These results should be interpreted cautiously; [20] presents an interesting discussion about issues
with these datasets. Also, benchmarking of ranking algorithms is still in its infancy and we don’t yet
have publicly available code for all of the competitive methods. We expect this situation to change
in the near future so that we are able to compare them on a fair and transparent basis.
Consistency In a second experiment we trained RankMatch with different training subset sizes,
starting with 0.03 ·D(k) ·M and going up to 1.0 ·D(k) ·M . Once again, we repeated the experiments
with DORM using precisely the same training subsets. The purpose here is to see whether we
observe a practical advantage of our method with increasing sample size, since statistical consistency
only provides an asymptotic indication. The results are plotted in Figure 3-right, where we can see
that, as more training data is available, RankMatch improves more saliently than DORM.
Runtime The runtime of our algorithm is competitive with that of max-margin for small graphs, such
as those that arise from the ranking application. For larger graphs, the use of the sampling algorithm
will result in much slower runtimes than those typically obtained in the max-margin framework.
This is certainly the beneﬁt of the max-margin matching formulations of [4, 13]: it is much faster
for large graphs. Table 1 shows the runtimes for graphs of different sizes, for both estimators.

5.2
Image Matching
For our computer vision application we used a silhouette image from the Mythological Creatures
2D database3 . We randomly selected 20 points on the silhouette as our interest points and applied

3 http://tosca.cs.technion.ac.il

7

shear to the image creating 200 different images. We then randomly selected N pairs of images for
training, N for validation and 500 for testing, and trained our model to match the interest points
in the pairs – that is, given two images with corresponding points, we computed descriptors for
each pair i, j of points (one from each image) and learned θ such that the solution to the matching
problem (2) with the weights set to wij = (cid:104)xij , θ(cid:105) best matches the expected solution that a human
would manually provide. In this setup,
xij = |ψi − ψj |2 , where | · | denotes the elementwise difference
and ψi is the Shape Context feature vector [1] for point i.
For a graph of this size computing the exact expectation is not feasible, so we used the sampling
method described in Section 4.3. Once again, the regularization constant λ was chosen by cross-
validation. Given the fact that the MAP estimator is consistent while the max-margin estimator is
not, one is tempted to investigate the practical performance of both estimators as the sample size
grows. However, since consistency is only an asymptotic property, and also since the Hamming
loss is not the criterion optimized by either estimator, this does not imply a better large-sample
performance of MAP in real experiments. In any case, we present results with varying training set
sizes in Figure 3-left. The max-margin method is that of [4]. After a sufﬁciently large training set
size, our model seems to enjoy a slight advantage.

(19)

Figure 3: Performance with increasing sample size. Left: Hamming loss for different numbers of
training pairs in the image matching problem (test set size ﬁxed to 500 pairs). Right: results of
NDCG@1 on the ranking dataset OHSUMED. This evidence is in agreement with the fact that our
estimator is consistent, while max-margin is not.
6 Conclusion and Discussion
We presented a method for learning max-weight bipartite matching predictors, and applied it ex-
tensively to well-known document ranking datasets, obtaining state-of-the-art results. We also
illustrated–with an image matching application–that larger problems can also be solved, albeit
slowly, with a recently developed sampler. The method has a number of convenient features. First,
it consists of performing maximum-a-posteriori estimation in an exponential family model, which
results in a simple unconstrained convex optimization problem solvable by standard algorithms such
as BFGS. Second, the estimator is not only statistically consistent but also in practice it seems to
beneﬁt more from increasing sample sizes than its max-margin alternative. Finally, being fully prob-
abilistic, the model can be easily integrated as a module in a Bayesian framework, for example. The
main direction for future research consists of ﬁnding more efﬁcient ways to solve large problems.
This will most likely arise from appropriate exploitation of data sparsity in the permutation group.

References
[1] Belongie, S., & Malik, J (2000). Matching with shape contexts. CBAIVL00.
[2] Belongie, S., Malik, J., & Puzicha, J. (2002). Shape matching and object recognition using shape contexts.
IEEE Trans. on PAMI, 24, 509–521.
[3] Burges, C. J. C., Shaked, T., Renshaw, E., Lazier, A., Deeds, M., Hamilton, N. & Hulldender, G. (2005).
Learning to rank using gradient descent. ICML.

8

0501001502002503003504004505000.080.10.120.140.160.180.2number of training pairserror  exponential modelmax margingrows.However,sinceconsistencyisonlyanasymptoticproperty,andalsosincetheHamminglossisnotthecriterionoptimizedbyeitherestimator,thisdoesnotimplyabetterlarge-sampleperformanceofMAPinrealexperiments.Inanycase,wepresentresultswithvaryingtrainingsetsizesinFigure2.InFigure??wecanseeanexampleofamatchwithandwithoutlearning.Themax-marginmethodisthatof[?].Themethodsperformalmostidenticallyafterasufﬁcientlylargetrainingsetsize,althoughtheexperimentwastruncatedat500training/testingpairsduetocomputationaloverload.(Thedatasethasintotalabout20,000differentimagepairs.)0501001502002503003504004505000.080.10.120.140.160.180.2number of training pairserror  max marginexponential modelFigure3:Left:matchwithoutlearning(6/20correctmatches).Right:matchwithlearning(14/20correctmatches)andtrainingofθproceedsasexplainedinSection4.TestingAttesttime,wearegivenaqueryqanditscorrespondinglistofDassociateddocuments.Wethenhavetosolvethepredictionproblem,i.e.y∗=argmaxyDXi=1(cid:10)xiy(i),θ(cid:11)(19a)=argmaxyDXi=1cy(i)hψi,θi.(19b)Wenownoticethatifthescalarcj=c(j),wherecisanon-increasingfunctionofrankpositionj,then(19b)canbesolvedsimplybysortingthevaluesofhψi,θiindecreasingorder.3Inotherwords,thematchingproblembecomesoneofrankingthevalueshψi,θi.Inferenceinourmodelisthereforeveryfast(lineartime).4Inthissettingitmakessensetointerpretthequantityhψi,θiasascoreofdocumentdiforqueryq.Thisleavesopenthequestionofwhichnon-increasingfunctioncshouldbeused.Wedonotsolvethisprobleminthispaper,andinsteadchooseaﬁxedc.Intheoryitispossibletooptimizeovercduringlearning,butinthatcasetheoptimizationproblemwouldnolongerbeconvex.WedescribetheresultsofourmethodonLETOR2.0[22],apubliclyavailablebenchmarkdatacollectionforcomparinglearningtorankalgorithms.Itiscomprisedofthreedatasets:OHSUMED,TD2003andTD2004.DatasetsOHSUMEDcontainsfeaturesextractedfromquery-documentpairsintheOHSUMEDcollection,asubsetofMEDLINE,adatabaseofmedicalpublications.Itcontains106queries.Foreachquerythereareanumberofassociateddocuments,withrelevancedegreesjudgedbyhumansonthreelevels:deﬁnitely,possiblyornotrelevant.Eachquery-documentpairhasa25dimensionalfeaturevectorassociated(ourψi).Thetotalnumberofquery-documentpairsis16,140.TD2003andTD2004containfeaturesextractedfromthetopicdistillationtasksofTREC2003andTREC2004,with50and75queriesrespectively.Again,foreachquerythereareanumberofassociateddocuments,withrelevancedegreesjudgedbyhumans,butinthiscaseonlytwolevelsareprovided:relevantornotrelevant.Eachquery-documentpairhasa44dimensionalfeaturevectorassociated(ourψi).Thetotalnumberofquery-documentpairsis49,171forTD2003and74,170forTD2004.Alldatasetsarealreadypartitionedfor5-foldcross-validation.See[22]formoredetail.EvaluationMetricsInordertomeasuretheeffectivenessofourmethodweusethenormalizeddiscountcumulativegain(NDCG)measure[16]atrankpositionk,whichisdeﬁnedasNDCG@k=1ZkXj=12r(j)−1log(1+j),(20)wherer(j)istherelevanceofthejthdocumentinthelist,andZisanormalizationconstantsothataperfectrankingyieldsanNDCGscoreof1.3Ifr(v)denotesthevectorofranksofentriesofvectorv,thenha,π(b)iismaximizedbythepermutationπ∗suchthatr(a)=r(π∗(b)),atheoremduetoPolya,Littlewood,HardyandBlackwell[31].4SortingthetopkitemsofalistofDitemstakesO(klogk+D)timewithaquicksort-styleagorithm.7Figure2:Learningimagematching:hamminglossfordifferentnumberoftrainingpairs(testsetsizeﬁxedto500pairs).5.2RankingHereweapplythegeneralmatchingmodelintroducedinprevioussectionstothetaskoflearningtorank.Rankingisafundamentalproblemwithapplicationsindiverseareassuchasdocumentretrieval,recommendersystems,productratingandothers.Wearegoingtofocusonwebpageranking.Forthisproblemwearegivenasetofqueries{qk}and,foreachqueryqk,alistofD(k)documents{dk1,...,dkD(k)}withcorrespondingratings{rk1,...,rkD(k)}(assignedbyahumaneditor),measur-ingtherelevancedegreeofeachdocumentwithrespecttoqueryqk.Aratingorrelevancedegreeisusuallyanominalvalueinthelist{1,...,R},whereRistypicallybetween2and5.Wearealsogiven,foreveryretrieveddocumentdki,ajointfeaturevectorψkiforthatdocumentandthequeryqk.TrainingAttrainingtime,wemodeleachqueryqkasavector-weightedbipartitegraph(Figure1)wherethenodesononesidecorrespondtoasubsetofcardinalityMofallD(k)documentsretrievedbythequery,andthenodesontheothersidecorrespondtoallpossiblerankingpositionsforthesedocuments(1,...,M).Thesubsetitselfischosenrandomly,providedatleastoneexemplardocumentofeveryratingispresent.ThereforeMmustbesuchthatM≥R.Theprocessisthenrepeatedinabootstrapmanner:weresample(withreplacement)fromthesetofdocuments{dk1,...,dkD(k)},Mdocumentsatatime(conditionedonthefactthatatleastone610−11000.530.5350.540.5450.550.5550.560.5650.57sample size (x M D)NDCG−1OHSUMED  RankMatchDORMFigure2:Learningimagematching.Left:hamminglossfordifferentnumbersoftrainingpairs(testsetsizeﬁxedto500pairs).Right:anexamplematchfromthetestset(bluearecorrectandredincorrectmatches).retrieval,recommendersystems,productratingandothers.Wearegoingtofocusonwebpageranking.Forthisproblemwearegivenasetofqueries{qk}and,foreachqueryqk,alistofD(k)documents{dk1,...,dkD(k)}withcorrespondingratings{rk1,...,rkD(k)}(assignedbyahumaneditor),measur-ingtherelevancedegreeofeachdocumentwithrespecttoqueryqk.Aratingorrelevancedegreeisusuallyanominalvalueinthelist{1,...,R},whereRistypicallybetween2and5.Wearealsogiven,foreveryretrieveddocumentdki,ajointfeaturevectorψkiforthatdocumentandthequeryqk.TrainingAttrainingtime,wemodeleachqueryqkasavector-weightedbipartitegraph(Figure1)wherethenodesononesidecorrespondtoasubsetofcardinalityMofallD(k)documentsretrievedbythequery,andthenodesontheothersidecorrespondtoallpossiblerankingpositionsforthesedocuments(1,...,M).Thesubsetitselfischosenrandomly,providedatleastoneexemplardocumentofeveryratingispresent.ThereforeMmustbesuchthatM≥R.Theprocessisthenrepeatedinabootstrapmanner:weresample(withreplacement)fromthesetofdocuments{dk1,...,dkD(k)},Mdocumentsatatime(conditionedonthefactthatatleastoneexemplarofeveryratingispresent,butotherwiserandomly).Thiseffectivelybooststhenumberoftrainingexamplessinceeachqueryqkendsupbeingselectedmanytimes,eachtimewithadifferentsubsetofMdocumentsfromtheoriginalsetofD(k)documents.Inthefollowingwedropthequeryindexksinceweexamineasinglequery.Herewefollowtheconstructionusedin[21]tomapmatchingproblemstorankingproblems.(Indeedtheonlydifferencebetweenourrankingmodelandthatof[21]isthattheyuseamax-marginestimatorandweuseMAPinanexponentialfamily.)Ouredgefeaturevectorxijwillbetheproductoffeaturevectorψiassociatedwithdocumenti,andascalarcj(thechoiceofwhichwillbeexplainedbelow)associatedwithrankingpositionjxij=ψicj.(17)ψiisdatasetspeciﬁc(detailsbelow).Wethereforehavefrom(10)and(17)thatwij=cjhψi,θi,(18)andtrainingofθproceedsasexplainedinSection4.6[4] Caetano, T. S., Cheng, L., Le, Q. V., & Smola, A. J. (2009). Learning graph matching. IEEE Trans. on
PAMI, 31, 1048–1058.
[5] Cao, Z., Qin, T., Liu, T.-Y., Tsai, M.-F., & Li, H. (2007). Learning to rank: from pairwise approach to
listwise approach. ICML
[6] Freund, Y., Iyer, R., Schapire, R. E., & Singer, Y. (2003). An efﬁcient boosting algorithm for combining
preferences. J. Mach. Learn. Res., 4, 933–969.
[7] Herbrich, A., Graepel, T., & Obermayer, K. (2000). Large margin rank boundaries for ordinal regression.
In Advances in Large Margin Classiﬁers.
[8] Huang, B., & Jebara, T. (2007). Loopy belief propagation for bipartite maximum weight b-matching.
AISTATS.
[9] Huang, J. C., & Frey, B. J. (2008). Structured ranking learning using cumulative distribution networks. In
NIPS.
[10] Huber, M., & Law, J. (2008). Fast approximation of the permanent for very dense problems. SODA.
[11] Jarvelin, K., & Kekalainen, J. (2002). Cumulated gain-based evaluation of ir techniques. ACM Transac-
tions on Information Systems, 20, 2002.
[12] Lafferty, J. D., McCallum, A., & Pereira, F. (2001). Conditional random ﬁelds: Probabilistic modeling
for segmenting and labeling sequence data. ICML.
[13] Le, Q., & Smola, A. (2007). Direct optimization of ranking measures. http://arxiv.org/abs/0704.3359.
[14] Liu, T.-Y., Xu, J., Qin, T., Xiong, W., & Li, H. (2007). Letor: Benchmark dataset for research on learning
to rank for information retrieval. LR4IR.
[15] Liu, Y. & Shen, X. (2005) Multicategory ψ -learning and support vector machine: Computational tools.
J. Computational and Graphical Statistics, 14, 219–236.
[16] Liu, Y. & Shen, X. (2006) Multicategory ψ -learning. JASA, 101, 500–509.
[17] Martinez, C. (2004). Partial quicksort. SIAM.
[18] McAllester, D. (2007). Generalization bounds and consistency for structured labeling. Predicting Struc-
tured Data.
[19] Minc, H. (1978). Permanents. Addison-Wesley.
[20] Minka, T., & Robertson, S. (2008). Selection bias in the letor datasets. LR4IR.
[21] Nocedal, J., & Wright, S. J. (1999). Numerical optimization. Springer Series in Operations Research.
Springer.
[22] Papadimitriou, C. H., & Steiglitz, K. (1982). Combinatorial optimization: Algorithms and complexity.
New Jersey: Prentice-Hall.
[23] Qin, T., Liu, T.-Y., Zhang, X.-D., Wang, D.-S., & Li, H. (2009). Global ranking using continuous condi-
tional random ﬁelds. NIPS.
[24] Rigutini, L., Papini, T., Maggini, M., & Scarselli, F. (2008). Sortnet: Learning to rank by a neural-based
sorting algorithm. LR4IR.
[25] Ryser, H. J. (1963). Combinatorial mathematics. The Carus Mathematical Monographs, No. 14, Mathe-
matical Association of America.
[26] Sherman, S. (1951). On a Theorem of Hardy, Littlewood, Polya, and Blackwell. Proceedings of the
National Academy of Sciences, 37, 826–831.
[27] Taskar, B. (2004). Learning structured prediction models: a large-margin approach. Doctoral disserta-
tion, Stanford University.
[28] Tsai, M., Liu, T., Qin, T., Chen, H., & Ma, W. (2007). Frank: A ranking method with ﬁdelity loss. SIGIR.
[29] Tsochantaridis, I., Joachims, T., Hofmann, T., & Altun, Y. (2005). Large margin methods for structured
and interdependent output variables. JMLR, 6, 1453–1484.
[30] Valiant, L. G. (1979). The complexity of computing the permanent. Theor. Comput. Sci. (pp. 189–201).
[31] Wainwright, M. J., & Jordan, M. I. (2003). Graphical models, exponential families, and variational
inference (Technical Report 649). UC Berkeley, Department of Statistics.
[32] Xu, J., & Li, H. (2007). Adarank: a boosting algorithm for information retrieval. SIGIR.
[33] Zheng, Z., Zha, H., & Sun, G. (2008a). Query-level learning to rank using isotonic regression. LR4IR.
[34] Zheng, Z., Zha, H., Zhang, T., Chapelle, O., Chen, K., & Sun, G. (2008b). A general boosting method
and its application to learning ranking functions for web search. NIPS.

9

