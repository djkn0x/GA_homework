Agreement-Based Learning

Percy Liang
Computer Science Division
University of California
Berkeley, CA 94720
pliang@cs.berkeley.edu

Dan Klein
Computer Science Division
University of California
Berkeley, CA 94720
klein@cs.berkeley.edu

Michael I. Jordan
Computer Science Division
University of California
Berkeley, CA 94720
jordan@cs.berkeley.edu

Abstract

The learning of probabilistic models with many hidden variables and non-
decomposable dependencies is an important and challenging problem. In contrast
to traditional approaches based on approximate inference in a single intractable
model, our approach is to train a set of tractable submodels by encouraging them
to agree on the hidden variables. This allows us to capture non-decomposable
aspects of the data while still maintaining tractability. We propose an objective
function for our approach, derive EM-style algorithms for parameter estimation,
and demonstrate their effectiveness on three challenging real-world learning tasks.

1

Introduction

Many problems in natural language, vision, and computational biology require the joint modeling of
many dependent variables. Such models often include hidden variables, which play an important role
in unsupervised learning and general missing data problems. The focus of this paper is on models
in which the hidden variables have natural problem domain interpretations and are the object of
inference.
Standard approaches for learning hidden-variable models involve integrating out the hidden vari-
ables and working with the resulting marginal likelihood. However, this marginalization can be in-
tractable. An alternative is to develop procedures that merge the inference results of several tractable
submodels. An early example of such an approach is the use of pseudolikelihood [1], which deals
with many conditional models of single variables rather than a single joint model. More generally,
composite likelihood permits a combination of the likelihoods of subsets of variables [7]. Another
approach is piecewise training [10, 11], which has been applied successfully to several large-scale
learning problems.
All of the above methods, however, focus on fully-observed models. In the current paper, we develop
techniques in this spirit that work for hidden-variable models. The basic idea of our approach is to
create several tractable submodels and train them jointly to agree on their hidden variables. We
present an intuitive objective function and efﬁcient EM-style algorithms for training a collection of
submodels. We refer to this general approach as agreement-based learning.
Sections 2 and 3 presents the general theory for agreement-based learning. In some applications, it
is infeasible computationally to optimize the objective function; Section 4 provides two alternative
objectives that lead to tractable algorithms. Section 5 demonstrates that our methods can be ap-
plied successfully to large datasets in three real world problem domains—grammar induction, word
alignment, and phylogenetic hidden Markov modeling.

1

2 Agreement-based learning of multiple submodels

(1)

(2)

Assume we have M (sub)models pm (x, z; θm ), m = 1, . . . , M , where each submodel speciﬁes a
distribution over the observed data x ∈ X and some hidden state z ∈ Z . The submodels could be
parameterized in completely different ways as long as they are deﬁned on the common event space
X × Z . Intuitively, each submodel should capture a different aspect of the data in a tractable way.
To learn these submodels, the simplest approach is to train them independently by maximizing the
pm (x, z; θm ) = (cid:88)
(cid:88)
Oindep (θ) def= log (cid:89)
sum of their log-likelihoods:
where θ = (θ1 , . . . , θM ) is the collective set of parameters and pm (x; θm ) = (cid:80)
log pm (x; θm ),
z
m
m
z pm (x, z; θm )
is the likelihood under submodel pm .1 Given an input x, we can then produce an output z by
combining the posteriors pm (z | x; θm ) of the trained submodels.
If we view each submodel as trying to solve the same task of producing the desired posterior over
z, then it seems advantageous to train the submodels jointly to encourage “agreement on z.” We
(cid:89)
Oagree (θ) def= log (cid:88)
(cid:89)
log pm (x; θm ) + log (cid:88)
pm (x, z; θm ) = (cid:88)
propose the following objective which realizes this insight:
z
z
m
m
m
The last term rewards parameter values θ for which the submodels assign probability mass to the
same z (conditioned on x); the summation over z reﬂects the fact that we do not know what z is.
by a different submodel: p((x1 , z1 ), . . . , (xM , zM ); θ) = (cid:81)
Oagree has a natural probabilistic interpretation. Imagine deﬁning a joint distribution over M inde-
pendent copies over the data and hidden state, (x1 , z1 ), . . . , (xM , zM ), which are each generated
m p(xm , zm ; θm ). Then Oagree is the
probability that the submodels all generate the same observed data x and the same hidden state:
p(x1 = · · · = xM = x, z1 = · · · = zM ; θ).
Oagree is also related to the likelihood of a proper probabilistic model pnorm , obtained by normalizing
the product of the submodels, as is done in [3]. Our objective Oagree is then a lower bound on the
(cid:81)
(cid:80)
(cid:81)
(cid:80)
likelihood under pnorm :
(cid:80)
(cid:81)
(cid:81)
(cid:80)
m pm (x, z; θm )
m pm (x, z; θm )
z
z
pm (x, z; θm )
pm (x, z; θm )
x,z
x,z
m
m
The inequality holds because the denominator of the lower bound contains additional cross terms.
its own set of (nuisance) hidden variables: ppoe (x) ∝ (cid:81)
(cid:80)
The bound is generally loose, but becomes tighter as each pm becomes more deterministic. Note
that pnorm is distinct from the product-of-experts model [3], in which each “expert” model pm has
z pm (x, z; θm ). In contrast, pnorm has
m
one set of hidden variables z common to all submodels, which is what provides the mechanism for
agreement-based learning.

pm (z | x; θm ).

pnorm (x; θ) def=

= Oagree (θ).

(3)

≥

2.1 The product EM algorithm
We now derive the product EM algorithm to maximize Oagree . Product EM bears many striking
similarities to EM: both are coordinate-wise ascent algorithms on an auxiliary function and both
(cid:81)
(cid:81)
increase the original objective monotonically. By introducing an auxiliary distribution q(z) and
Oagree (θ) = log (cid:88)
applying Jensen’s inequality, we can lower bound Oagree with an auxiliary function L:
m pm (x, z; θm )
m pm (x, z; θm )
def= L(θ , q)
≥ Eq(z) log
q(z)
q(z)
q(z)
z
mizing a KL-divergence: L(θ , q) = −KL(q(z)|| (cid:81)
The product EM algorithm performs coordinate-wise ascent on L(θ , q). In the (product) E-step, we
optimize L with respect to q . Simple algebra reveals that this optimization is equivalent to mini-
m pm (x, z; θm )) + constant, where the constant
1To simplify notation, we consider one data point x. Extending to a set of i.i.d. points is straightforward.

(4)

2

does not depend on q . This quantity is minimized by setting q(z) ∝ (cid:81)
L(θ , q) = (cid:80)
m pm (x, z; θm ). In the (prod-
uct) M-step, we optimize L with respect to θ , which decomposes into M independent objectives:
Eq log pm (x, z; θm ) + constant, where this constant does not depend on θ . Each
term corresponds to an independent M-step, just as in EM for maximizing Oindep .
m
Thus, our product EM algorithm differs from independent EM only in the E-step, in which the
submodels are multiplied together to produce one posterior over z rather than M separate ones.
Assuming that there is an efﬁcient EM algorithm for each submodel pm , there is no difﬁculty in
performing the product M-step. In our applications (Section 5), each pm is composed of multinomial
distributions, so the M-step simply involves computing ratios of expected counts. On the other hand,
the product E-step can become intractable and we must develop approximations (Section 4).

3 Exponential family formulation

Thus far, we have placed no restrictions on the form of the submodels. To develop a richer under-
standing and provide a framework for making approximations, we now assume that each submodel
pm is an exponential family distribution:
where φm are sufﬁcient statistics (features) and Am (θm ) = log (cid:80)
pm (x, z; θm ) = exp{θT
mφm (x, z) − Am (θm )} for x ∈ X , z ∈ Zm and 0 otherwise,
(5)
exp{θT
mφm (x, z)} is
x∈X ,z∈Zm
the log-partition function,2 deﬁned on θm ∈ Θm ⊂ RJ . We can think of all the submodels pm as
being deﬁned on a common space Z∪ = ∪mZm , but the support of q(z) as computed in the E-step is
only the intersection Z∩ = ∩mZm . Controlling this support will be essential in developing tractable
approximations (Section 4.1).
In the general formulation, we required only that the submodels share the same event space X ×
Z . Now we make explicit the possibility of the submodels sharing features, which give us more
structure for deriving approximations. In particular, suppose each feature j of submodel pm can be
decomposed into a part that depends on x (which is speciﬁc to that particular submodel) and a part
I(cid:88)
that depends on z (which is the same for all submodels):
φX
mj i (x)φZ
i (z), or in matrix notation, φm (x, z) = φX
m (x)φZ (z),
φmj (x, z) =
(6)
i=1
m (x) is a J × I matrix and φZ (z) is a I × 1 vector. When z is discrete, such a decompo-
where φX
sition always exists by deﬁning φZ (z) to be an |Z∪ |-dimensional indicator vector which is 1 on the
(cid:16) (cid:88)
(cid:17)
(Eq(z)φZ (z)) + H (q) − (cid:88)
component corresponding to z. Fortunately, we can usually obtain more compact representations of
φZ (z). We can now express our objective L(θ , q) (4) using (5) and (6):
L(θ , q) =
Am (θm ) for q ∈ Q(Z∩ ),
mφX
m (x)
θT
m (x) and b = (cid:80)
m
m
where Q(Z (cid:48) ) def= {q : q(z) = 0 for z (cid:54)∈ Z (cid:48) } is the set of distributions with support Z (cid:48) . For
mφX
m = θT
convenience, deﬁne bT
m bm , which summarize the parameters θ for the
E-step. Note that for any θ , the q maximizing L always has the following exponential family form:
where AZ∩ (β ) = log (cid:80)
q(z; β ) = exp{β T φZ (z) − AZ∩ (β )} for z ∈ Z∩ and 0 otherwise,
(8)
z∈Z∩ exp{β T φZ (z)} is the log-partition function. In a minor abuse of
notation, we write L(θ , β ) = L(θ , q(·; β )). Speciﬁcally, L(θ , β ) is maximized by setting β = b.
It will be useful to express (7) using convex duality [12]. The key idea of convex duality is the
existence of a mapping between the canonical exponential parameters β ∈ RI of an exponential
family distribution q(z; β ) and the mean parameters deﬁned by µ = Eq(z;β )φZ (z) ∈ M(Z∩ ) ⊂ RI ,
where M(Z (cid:48) ) = {µ : ∃q ∈ Q(Z (cid:48) ) : Eq φZ (z) = µ} is the set of realizable mean parameters. The
Fenchel-Legendre conjugate of the log-partition function AZ∩ (β ) is
{β T µ − AZ∩ (β )} for µ ∈ M(Z∩ ),
A∗
Z∩ (µ) def= sup
β∈RI

(7)

(9)

2Our applications use directed graphical models, which correspond to curved exponential families where
each Θm is deﬁned by local normalization constraints and Am (θm ) = 0.

3

which is also equal to −H (q(z; β )), the negative entropy of any distribution q(z; β ) corresponding
(cid:16) (cid:88)
(cid:17)
Z∩ (µ) − (cid:88)
to µ. Substituting µ and A∗
Z∩ (µ) into (7), we obtain an objective in terms of the dual variables µ:
L∗ (θ , µ) def=
Am (θm ) for µ ∈ M(Z∩ ).
µ − A∗
mφX
m (x)
(10)
θT
m
m
Note that the two objectives are equivalent: supβ∈RI L(θ , β ) = supµ∈M(Z∩ ) L∗ (θ , µ) for each θ .
The mean parameters µ are exactly the z-speciﬁc expected sufﬁcient statistics computed in the prod-
uct E-step. The dual is an attractive representation because it allows us to form convex combinations
of different µ, an operation does not have a direct correlate in the primal formulation. The product
EM algorithm is summarized below:

E-step:
M-step:

Product EM
µ = argmaxµ(cid:48)∈M(Z∩ ){bT µ(cid:48) − A∗
Z∩ (µ(cid:48) )}
m φX (x)µ − Am (θ (cid:48)
m∈Θm {θ (cid:48)T
m )}
θm = argmaxθ(cid:48)

4 Approximations

The product M-step is tractable provided that the M-step for each submodel is tractable, which
is generally the case. The corresponding statement is not true for the E-step, which in general
requires explicitly summing over all possible z ∈ Z∩ , often an exponentially large set. We will thus
consider alternative E-steps, so it will be convenient to succinctly characterize an E-step. An E-step
is speciﬁed by a vector b(cid:48) (which depends on θ and x) and a set Z (cid:48) (which we sum z over):
E (b(cid:48) , Z (cid:48) ) computes µ = argmax
{b(cid:48)T µ(cid:48) − A∗
Z (cid:48) (µ(cid:48) )}.
(11)
µ(cid:48)∈M(Z (cid:48) )
Using this notation, E (bm , Zm ) is the E-step for training the m-th submodel independently using
EM and E (b, Z∩ ) is the E-step of product EM. Though we write E-steps in the dual formulation, in
practice, we compute µ as an expectation over all z ∈ Z (cid:48) , perhaps leveraging dynamic programming.
If E (bm , Zm ) is tractable and all submodels have the same dynamic programming structure (e.g.,
if z is a tree and all features are local with respect to that tree), then E (b, Z∩ ) is also tractable: we
can incorporate all the features into the same dynamic program and simply run product EM (see
Section 5.1 for an example).
model, but the combined b = (cid:80)
However, E (b, Z∩ ) is intractable in general, owing to two complications: (1) we can sum over each
Zm efﬁciently but not the intersection Z∩ ; and (2) each bm corresponds to a decomposable graphical
m bm corresponds to a loopy graph. In the sequel, we describe two
approximate objective functions addressing each complication, whose maximization can be carried
out by performing M independent tractable E-steps.

4.1 Domain-approximate product EM
Assume that for each submodel pm , E (b, Zm ) is tractable (see Section 5.2 for an example). We
(cid:104)(cid:16) (cid:88)
(cid:105) − (cid:88)
(cid:17)
(cid:88)
propose maximizing the following objective:
1
µm − A∗
L∗
m(cid:48) φX
dom (θ , µ1 , . . . , µm ) def=
(µm )
m(cid:48) (x)
Am (θm ),
θT
Zm
M
m(cid:48)
m
m
with each µm ∈ M(Zm ). This objective can be maximized via coordinate-wise ascent:
(cid:17) − Am (θ (cid:48)
(cid:16) 1
Domain-approximate product EM
(cid:80)
m∈M(Zm ) {bT µ(cid:48)
m − A∗
m )}
(µ(cid:48)
µm = argmaxµ(cid:48)
Zm
m∈Θm {θ (cid:48)T
m )}
m φX (x)
θm = argmaxθ(cid:48)
m(cid:48) µm(cid:48)
M
The product E-step consists of M separate E-steps, which are each tractable because each involves
the respective Zm instead of Z∩ . The resulting expected sufﬁcient statistics are averaged and used
in the product M-step, which breaks down into M separate M-steps.

E-step:
M-step:

(12)

[E (b, Zm )]

4

While we have not yet established any relationship between our approximation L∗
dom and the original
dom to L∗
objective L∗ , we can, however, relate L∗
∪ , which is deﬁned as an analogue of L∗ by replacing
Z∩ with Z∪ in (10).
(cid:80)
Proposition 1. L∗
dom (θ , µ1 , . . . , µM ) ≤ L∗
∪ (θ , ¯µ) for all θ and µm ∈ M(Zm ) and ¯µ =
m µm .
1
M
(cid:80)
(cid:80)
Proof. First, since M(Zm ) ⊂ M(Z∪ ) and M(Z∪ ) is a convex set, ¯µ ∈ M(Z∪ ), so L∗
∪ (θ , ¯µ)
is well-deﬁned. Subtracting the L∪ version of (10) from (12), we obtain L∗
dom (θ , µ1 , . . . , µM ) −
(cid:80)
Z∪ ( ¯µ) − 1
L∗
Z∪ ( ¯µ) ≤ 1
Z∪ (µm ) ≤
∪ (θ , ¯µ) = A∗
m A∗
m A∗
(µm ). It sufﬁces to show A∗
Zm
Z∪ (·). For the second inequality:
M
M
(µm ). The ﬁrst inequality follows from convexity of A∗
m A∗
1
Zm
since Zm ⊃ Z∪ , AZ∪ (µm ) ≥ AZm (µm ); by inspecting (9), it follows that A∗
Z∪ (µm ) ≤ A∗
M
(µm ).
Zm

Am (θm ),

(13)

4.2 Parameter-approximate product EM
Now suppose that for each submodel pm , E (bm , Z∩ ) is tractable (see Section 5.3 for an example).
(cid:105) − (cid:88)
(cid:104)
(cid:88)
We propose maximizing the following objective:
1
m (x))µm − A∗
L∗
mφX
par (θ , µ1 , . . . , µm ) def=
(M θT
Z∩ (µm )
M
m
m
with each µm ∈ M(Z∩ ). This objective can be maximized via coordinate-wise ascent, which again
consists of M separate E-steps E (M bm , Z∩ ) and the same M-step as before:
(cid:16) 1
(cid:17) − Am (θ (cid:48)
Parameter-approximate product EM
(cid:80)
m )}
m − A∗
m∈M(Zm ) {(M bm )T µ(cid:48)
Z∩ (µ(cid:48)
µm = argmaxµ(cid:48)
m∈Θm {θ (cid:48)T
m )}
m φX (x)
θm = argmaxθ(cid:48)
m(cid:48) µm(cid:48)
M
par is at least that of L∗ , which leaves us maximizing an
We can show that the maximum value of L∗
upper bound of L∗ . Although less logical than maximizing a lower bound, in Section 5.3, we show
that our approach is nonetheless a reasonable approximation which importantly is tractable.
par (θ , µ1 , . . . , µM ) ≥ maxµ∈M(Z∩ ) L∗ (θ , µ).
Proposition 2. maxµ1∈M(Z∩ ),...,µM ∈M(Z∩ ) L∗
par (13) and L∗ (10), it is easy to see that L∗
Proof. From the deﬁnitions of L∗
par (θ , µ, . . . , µ) =
L∗ (θ , µ) for all µ ∈ M(Z∩ ). If we maximize L∗
par with M distinct arguments, we cannot end up
with a smaller value.

[E (M bm , Z∩ )]

E-step:
M-step:

The product E-step could also be approximated by mean-ﬁeld or loopy belief propagation variants.
These methods and the two we propose all fall under the general variational framework for approx-
imate inference [12]. The two approximations we developed have the advantage of permitting exact
tractable solutions without resorting to expensive iterative methods which are only guaranteed to
converge to a local optima.
dom and L∗
While we still lack a complete theory relating our approximations L∗
par to the original
objective L∗ , we can give some intuitions. Since we are operating in the space of expected sufﬁcient
statistics µm , most of the information about the full posterior pm (z | x) must be captured in these
statistics alone. Therefore, we expect our approximations to be accurate when each submodel has
enough capacity to represent the posterior pm (z | x; θm ) as a low-variance unimodal distribution.

5 Applications

We now empirically validate our algorithms on three concrete applications: grammar induction using
product EM (Section 5.1), unsupervised word alignment using domain-approximate product EM
(Section 5.2), and prediction of missing nucleotides in DNA sequences using parameter-approximate
product EM (Section 5.3).

5

Figure 1: The two instances of IBM model 1 for word alignment are shown in (a) and (b). The graph
shows gains from agreement-based learning.

5.1 Grammar induction

Grammar induction is the problem of inducing latent syntactic structures given a set of observed
sentences. There are two common types of syntactic structure (one based on word dependencies and
the other based on constituent phrases), which can each be represented as a submodel. [5] proposed
an algorithm to train these two submodels. Their algorithm is a special case of our product EM
algorithm, although they did not state an objective function. Since the shared hidden state is a tree
structure, product EM is tractable. They show that training the two submodels to agree signiﬁcantly
improves accuracy over independent training. See [5] for more details.

5.2 Unsupervised word alignment

p1 (x, z; θ1 ) = p1 (e, f , a; θ1 ) = p1 (e)

Word alignment is an important component of machine translation systems. Suppose we have a set
of sentence pairs. Each pair consists of two sentences, one in a source language (say, English) and
its translation in a target language (say, French). The goal of unsupervised word alignment is to
match the words in a source sentence to the words in the corresponding target sentence. Formally,
let x = (e, f ) be an observed pair of sentences, where e = (e1 , . . . , e|e| ) and f = (f1 , . . . , f|f | ); z
is a set of alignment edges between positions in the English and positions in the French.
Classical models for word alignment include IBM models 1 and 2 [2] and the HMM model [8].
These are asymmetric models, which means that they assign non-zero probability only to alignments
in which each French word is aligned to at most one English word; we denote this set Z1 . An
element z ∈ Z1 can be parameterized by a vector a = (a1 , . . . , a|f | ), with aj ∈ {NU LL, 1, . . . , |e|},
corresponding to the English word (if any) that French word fj is aligned to. We deﬁne the ﬁrst
submodel on X × Z1 as follows (specializing to IBM model 1 for simplicity):
|f |(cid:89)
p1 (aj )p1 (fj | eaj ; θ1 ),
j=1
where p1 (e) and p1 (aj ) are constant and the canonical exponential parameters θ1 are the transition
log-probabilities {log t1;ef } for each English word e (including NU LL) and French word f .
Written in exponential family form, φZ (z) is an (|e| + 1)(|f | + 1)-dimensional vector whose com-
ponents are {φZ
ij (z) ∈ {0, 1} : i = NU LL, 1, . . . , |e|, j = NU LL, 1, . . . , |f |}. We have φZ
ij (z) = 1
if and only if English word ei is aligned to French word fj and zNU LLj = 1 if and only if fj is not
aligned to any English word. Also, φX
ef ;ij (x) = 1 if and only if ei = e and fj = f . The mean
parameters associated with an E-step are {µ1;ij }, the posterior probabilities of ei aligning to fj ;
these can be computed independently for each j . We can deﬁne a second submodel p2 (x, z; θ2 ) on
X × Z2 by reversing the roles of English and French. Figure 1(a)–(b) shows the two models.
We cannot use product EM algorithm to train p1 and p2 because summing over all alignments
in Z∩ = Z1 ∩ Z2 is NP-hard. However, we can use domain-approximate product EM because
E (b1 + b2 , Zm ) is tractable—the tractability here does not depend on decomposability of b but the
asymmetric alignment structure of Zm . The concrete change from independent EM is slight: we
need to only change the E-step of each pm to use the product of translation probabilities t1;ef t2;f e
and change the M-step to use the average of the edge posteriors obtained from the two E-steps.

(14)

6

e1e2e3a1a2a3a4f1f2f3f4e1e2e3a1a2a3f1f2f3f4(a)Submodelp1(b)Submodelp2 0.07 0.08 0.09 0.1 0.11 0.12 1 2 3 4 5 6 7 8 9 10alignment error rateiterationHMM modelIndependent EMDomain-approximate product EMFigure 2: The two phylogenetic HMM models, one for the even slices, the other for the odd ones.

[6] proposed an alternative method to train two models to agree. Their E-step computes µ1 =
E (b1 , Z1 ) and µ2 = E (b2 , Z2 ), whereas our E-steps incorporate the parameters of both models
in b1 + b2 . Their M-step uses the elementwise product of µ1 and µ2 , whereas we use the average
2 (µ1 + µ2 ). Finally, while their algorithm appears to be very stable and is observed to converge
1
empirically, no objective function has been developed; in contrast, our algorithm maximizes (12).
In practice, both algorithms perform comparably.
We conducted our experiments according to the setup of [6]. We used 100K unaligned sentences
for training and 137 for testing from the English-French Hansards data of the NAACL 2003 Shared
Task. Alignments are evaluated using alignment error rate (AER); see [6] for more details. We
trained two instances of the HMM model [8] (English-to-French and French-to-English) using 10
iterations of domain-approximate product EM, initializing with independently trained IBM model 1
parameters. For prediction, we output alignment edges with sufﬁcient posterior probability: {(i, j ) :
2 (µ1;ij + µ2;ij ) ≥ δ}. Figure 1 shows how agreement-based training improves the error rate over
1
independent training for the HMM models.

5.3 Phylogenetic HMM models
Suppose we have a set of species s ∈ S arranged in a ﬁxed phylogeny (i.e., S are the nodes
of a directed tree). Each species s is associated with a length L sequence of nucleotides ds =
(ds1 , . . . , dsL ). Let d = {ds : s ∈ S } denote all the nucleotides, which consist of some observed
ones x and unobserved ones z.
A good phylogenetic model should take into consideration both the relationship between nucleotides
of the different species at the same site and the relationship between adjacent nucleotides in the same
species. However, such a model would have high tree-width and be intractable to train. Past work
(cid:89)
(cid:89)
p1 (x, z; θ1 ) = p1 (d; θ1 ) = (cid:89)
has focused on traditional variational inference in a single intractable model [9, 4]. Our approach is
to instead create two tractable submodels and train them to agree. Deﬁne one submodel to be
p1 (ds(cid:48) j | dsj ; θ1 )p1 (ds(cid:48) j+1 | ds(cid:48) j , ds(j+1) ; θ1 ),
s∈S
s(cid:48)∈CH(s)
j odd
where CH(s) is the set of children of s in the tree. The second submodel p2 is deﬁned similarly,
only with the product taken over j even. The parameters θm consist of ﬁrst-order mutation log-
probabilities and second-order mutation log-probabilities. Both submodels permit the same set of
assignments of hidden nucleotides (Z∩ = Z1 = Z2 ). Figure 2(a)–(b) shows the two submodels.
Exact product EM is not tractable since b = b1 + b2 corresponds to a graph with high tree-width.
We can apply parameter-approximate product EM, in which the E-step only involves computing
µm = E (2bm , Z∩ ). This can be done via dynamic programming along the tree for each two-
2 (µ1 + µ2 ) is used for each model,
nucleotide slice of the sequence. In the M-step, the average 1
which has a closed form solution.
Our experiments used a multiple alignment consisting of L = 20, 000 consecutive sites belonging
to the L1 transposons in the Cystic Fibrosis Transmembrane Conductance Regulator (CFTR) gene
(chromosome 7). Eight eutherian species were arranged in the phylogeny shown in Figure 3. The
data we used is the same as that of [9]. Some nucleotides in the sequences were already missing. In
addition, we held out some fraction of the observed ones for evaluation. We trained two models using
30 iterations of parameter-approximate product EM.3 For prediction, the posteriors over heldout
3We initialized with a small amount of noise around uniform parameters plus a small bias towards identity
mutations.

(15)

7

dA1dB1dC1dD1dE1dA2dB2dC2dD2dE2dA3dB3dC3dD3dE3dA4dB4dC4dD4dE4dA1dB1dC1dD1dE1dA2dB2dC2dD2dE2dA3dB3dC3dD3dE3dA4dB4dC4dD4dE4(a)Submodelp1(b)Submodelp2Figure 3: The tree is the phylogeny topology used in experiments. The graphs show the predic-
tion accuracy of independent versus agreement-based training (parameter-approximate product EM)
when 20% and 50% of the observed nodes are held out.

nucleotides under each model are averaged and the one with the highest posterior is chosen. Figure 3
shows the prediction accuracy. Though independent and agreement-based training eventually obtain
the same accuracy, agreement-based training converges much faster. This gap grows as the amount
of heldout data increases.

6 Conclusion

We have developed a general framework for agreement-based learning of multiple submodels. View-
ing these submodels as components of an overall model, our framework permits the submodels to be
trained jointly without paying the computational cost associated with an actual jointly-normalized
probability model. We have presented an objective function for agreement-based learning and three
EM-style algorithms that maximize this objective or approximations to this objective. We have also
demonstrated the applicability of our approach to three important real-world tasks. For grammar in-
duction, our approach yields the existing algorithm of [5], providing an objective for that algorithm.
For word alignment and phylogenetic HMMs, our approach provides entirely new algorithms.

Acknowledgments We would like to thank Adam Siepel for providing the phylogenetic data
and acknowledge the support of the Defense Advanced Research Projects Agency under contract
NBCHD030010.

References
[1] J. Besag. The analysis of non-lattice data. The Statistician, 24:179–195, 1975.
[2] P. F. Brown, S. A. D. Pietra, V. J. D. Pietra, and R. L. Mercer. The mathematics of statistical machine
translation: Parameter estimation. Computational Linguistics, 19:263–311, 1993.
[3] G. Hinton. Products of experts. In International Conference on Artiﬁcial Neural Networks, 1999.
[4] V. Jojic, N. Jojic, C. Meek, D. Geiger, A. Siepel, D. Haussler, and D. Heckerman. Efﬁcient approximations
for learning phylogenetic HMM models from data. Bioinformatics, 20:161–168, 2004.
[5] D. Klein and C. D. Manning. Corpus-based induction of syntactic structure: Models of dependency and
constituency. In Association for Computational Linguistics (ACL), 2004.
[6] P. Liang, B. Taskar, and D. Klein. Alignment by agreement. In Human Language Technology and North
American Association for Computational Linguistics (HLT/NAACL), 2006.
[7] B. Lindsay. Composite likelihood methods. Contemporary Mathematics, 80:221–239, 1988.
[8] H. Ney and S. Vogel. HMM-based word alignment in statistical translation. In International Conference
on Computational Linguistics (COLING), 1996.
[9] A. Siepel and D. Haussler. Combining phylogenetic and hidden Markov models in biosequence analysis.
Journal of Computational Biology, 11:413–428, 2004.
[10] C. Sutton and A. McCallum. Piecewise training of undirected models. In Uncertainty in Artiﬁcial Intel-
ligence (UAI), 2005.
[11] C. Sutton and A. McCallum. Piecewise pseudolikelihood for efﬁcient CRF training.
Conference on Machine Learning (ICML), 2007.
[12] M. Wainwright and M. I. Jordan. Graphical models, exponential families, and variational inference.
Technical report, Department of Statistics, University of California at Berkeley, 2003.

In International

8

(hidden)(hidden)baboon(hidden)chimphuman(hidden)(hidden)cowpig(hidden)catdog(hidden)mouserat 0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75 0.8 0.85 0 5 10 15 20 25accuracyiteration20% heldoutIndependent EMParameter-approximate product EM 0.4 0.5 0.6 0.7 0.8 0 5 10 15 20 25accuracyiteration50% heldoutIndependent EMParameter-approximate product EM